--- File: ./src/monitor.py ---
from __future__ import annotations

import re
from typing import Awaitable, Callable

from telethon import TelegramClient, events
from telethon.sessions import StringSession

CA_PATTERN = re.compile(r"[1-9A-HJ-NP-Za-km-z]{32,44}")


def guess_chain(address: str) -> str:
    # Hex 0x... likely EVM/BSC, base58 lengths lean Solana
    if address.startswith("0x") and len(address) == 42:
        return "bsc"
    if len(address) >= 32 and len(address) <= 44:
        return "solana"
    return "bsc"


class Monitor:
    def __init__(
        self,
        api_id: int,
        api_hash: str,
        session: str,
        listen_chats: list[int],
        process_ca: Callable[[str, str], Awaitable[str | None]],
    ):
        self.client = TelegramClient(StringSession(session), api_id, api_hash)
        self.listen_chats = listen_chats
        self.process_ca = process_ca

    def setup(self):
        @self.client.on(events.NewMessage(chats=self.listen_chats))
        async def handler(event):
            text = event.raw_text or ""
            for ca in CA_PATTERN.findall(text):
                chain = guess_chain(ca)
                await self.process_ca(chain, ca)

    async def run(self):
        self.setup()
        await self.client.start()
        await self.client.run_until_disconnected()

--- File: ./src/models.py ---
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class HolderShare(BaseModel):
    address: str
    percent: float


class TokenMetrics(BaseModel):
    chain: str
    address: str
    symbol: str
    name: Optional[str]
    price_usd: Optional[float]
    price_change_5m: Optional[float] = None
    market_cap: Optional[float] = None
    liquidity_usd: Optional[float] = None
    pool_created_at: Optional[datetime] = None
    first_trade_at: Optional[datetime] = None  # ç¬¬ä¸€ä¸ªKçº¿çš„æ—¶é—´ï¼ˆçœŸæ­£çš„å¼€ç›˜æ—¶é—´ï¼‰
    trades_5m: Optional[int] = None
    holders: Optional[int] = None
    top10_ratio: Optional[float] = None
    max_holder_ratio: Optional[float] = None
    top5: List[HolderShare] = Field(default_factory=list)
    sol_sniffer_score: Optional[float] = None  # SolSniffer é£é™©è¯„åˆ† (0-100)
    token_sniffer_score: Optional[float] = None  # TokenSniffer é£é™©è¯„åˆ† (0-100)
    extra: Dict[str, Any] = Field(default_factory=dict)


class FilterRange(BaseModel):
    min: Optional[float] = None
    max: Optional[float] = None

    def is_set(self) -> bool:
        return self.min is not None or self.max is not None


class FilterConfig(BaseModel):
    market_cap_usd: FilterRange = FilterRange()
    liquidity_usd: FilterRange = FilterRange()
    open_minutes: FilterRange = FilterRange()
    top10_ratio: FilterRange = FilterRange()
    holder_count: FilterRange = FilterRange()
    max_holder_ratio: FilterRange = FilterRange()
    trades_5m: FilterRange = FilterRange()
    sol_sniffer_score: FilterRange = FilterRange()  # SolSniffer è¯„åˆ†ç­›é€‰ (0-100)
    token_sniffer_score: FilterRange = FilterRange()  # TokenSniffer è¯„åˆ†ç­›é€‰ (0-100)


class ChainConfig(BaseModel):
    rpc_url: str
    explorer: Optional[str] = None




--- File: ./src/task_scheduler.py ---
from __future__ import annotations

import asyncio
import logging
import time
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Optional

from telethon.errors import RPCError

from .client_pool import ClientPool

logger = logging.getLogger("ca_filter_bot.task_scheduler")

# ä¸­å›½æ—¶åŒºï¼ˆUTC+8ï¼‰
TZ_SHANGHAI = timezone(timedelta(hours=8))


class TaskScheduler:
    """
    è½»é‡çº§ä»»åŠ¡è°ƒåº¦å™¨ï¼š
    - åŸºäº interval_minutes è½®è¯¢è§¦å‘
    - æ”¯æŒ enable/disable
    - æ”¯æŒå¤šä¸ª client å¹¶è¡Œæ‰§è¡Œ
    """

    def __init__(self, client_pool: ClientPool, process_ca, state_store=None):
        self.client_pool = client_pool
        self.process_ca = process_ca
        self.state_store = state_store  # ç”¨äºåŒæ­¥çŠ¶æ€åˆ° state.json
        self.tasks: List[Dict[str, Any]] = []
        self._loop_task: Optional[asyncio.Task] = None
        self._state_watcher_task: Optional[asyncio.Task] = None
        self._state_mtime: Optional[float] = None

    def load_tasks(self, tasks_cfg: List[dict]) -> None:
        now = time.time()
        self.tasks = []
        for t in tasks_cfg:
            task = {
                "id": t.get("id") or t.get("name"),
                "name": t.get("name", "task"),
                "client": t.get("client"),
                "chain": t.get("chain", "solana"),
                "ca": t.get("ca"),
                "targets": t.get("targets", []),
                "interval_minutes": int(t.get("interval_minutes", 5)),
                "enabled": bool(t.get("enabled", True)),
                "next_run": now,
                "start_time": t.get("start_time"),
                "end_time": t.get("end_time"),
            }
            if not task["id"] or not task["client"] or not task["ca"]:
                logger.warning(f"âš ï¸ Skip invalid task config: {t}")
                continue
            
            # åŠ è½½æ—¶æ£€æŸ¥æ—¶é—´çª—ï¼Œå¦‚æœä¸åœ¨æ—¶é—´çª—å†…åˆ™è‡ªåŠ¨ç¦ç”¨
            has_window = task.get("start_time") or task.get("end_time")
            if has_window and task["enabled"]:
                if not self._is_in_time_window(task):
                    task["enabled"] = False
                    logger.info(f"â¸ï¸ Task {task['id']} auto-disabled on load (out of window {task.get('start_time')}~{task.get('end_time')})")
            
            self.tasks.append(task)
        if self.tasks:
            logger.info(f"âœ… Loaded {len(self.tasks)} task(s)")
        else:
            logger.info("â„¹ï¸ No tasks loaded")

    async def start(self):
        if self._loop_task:
            return
        self._loop_task = asyncio.create_task(self._run_loop(), name="task_scheduler_loop")
        logger.info("âœ… Task scheduler started")
        # å¦‚æœæä¾›äº† state_storeï¼Œå¯åŠ¨ä¸€ä¸ªåå°ä»»åŠ¡ç›‘å¬ state.json çš„å˜åŒ–å¹¶åŒæ­¥åˆ° scheduler
        if self.state_store and not self._state_watcher_task:
            try:
                self._state_watcher_task = asyncio.create_task(self._run_state_watcher(), name="task_scheduler_state_watcher")
                logger.info("ğŸ”” State watcher started for state.json changes")
            except Exception as e:
                logger.warning(f"âš ï¸ Failed to start state watcher: {e}")

    async def stop(self):
        if self._loop_task:
            self._loop_task.cancel()
            try:
                await self._loop_task
            except asyncio.CancelledError:
                pass
            logger.info("âœ… Task scheduler stopped")
        if self._state_watcher_task:
            self._state_watcher_task.cancel()
            try:
                await self._state_watcher_task
            except asyncio.CancelledError:
                pass
            logger.info("âœ… State watcher stopped")

    def list_tasks(self) -> List[Dict[str, Any]]:
        return self.tasks

    def add_task(self, task: Dict[str, Any]) -> bool:
        if any(t["id"] == task["id"] for t in self.tasks):
            return False
        now = time.time()
        task["next_run"] = now
        self.tasks.append(task)
        # åŒæ­¥å†™å›é…ç½®
        cfg_tasks = []
        for t in self.tasks:
            cfg_tasks.append({
                "id": t["id"],
                "name": t.get("name"),
                "client": t.get("client"),
                "chain": t.get("chain"),
                "ca": t.get("ca"),
                "targets": t.get("targets", []),
                "interval_minutes": t.get("interval_minutes", 5),
                "enabled": t.get("enabled", True),
                "start_time": t.get("start_time"),
                "end_time": t.get("end_time"),
            })
        self.client_pool.update_tasks_config(cfg_tasks)
        return True

    def pause(self, task_id: str) -> bool:
        for t in self.tasks:
            if t["id"] == task_id:
                t["enabled"] = False
                self.client_pool.update_tasks_config(self.tasks)
                return True
        return False

    def resume(self, task_id: str) -> bool:
        now = time.time()
        for t in self.tasks:
            if t["id"] == task_id:
                t["enabled"] = True
                t["next_run"] = now
                self.client_pool.update_tasks_config(self.tasks)
                return True
        return False

    async def _run_loop(self):
        while True:
            now = time.time()
            # Current wall clock in China timezone for logging/decisions
            now_dt_for_log = datetime.now(TZ_SHANGHAI)
            for task in self.tasks:
                # æ£€æŸ¥æ—¶é—´çª—ï¼Œè‡ªåŠ¨å¯ç”¨/ç¦ç”¨ä»»åŠ¡ï¼ˆåœ¨æ£€æŸ¥ enabled ä¹‹å‰ï¼‰
                try:
                    logger.debug(
                        "Checking time window for task %s: start=%s end=%s now=%s",
                        task.get("id"),
                        task.get("start_time"),
                        task.get("end_time"),
                        now_dt_for_log.strftime("%Y-%m-%d %H:%M:%S"),
                    )
                except Exception:
                    # ä¿è¯æ—¥å¿—è°ƒç”¨ä¸æŠ›å¼‚å¸¸
                    pass
                has_window = task.get("start_time") or task.get("end_time")
                if has_window:
                    in_window = self._is_in_time_window(task)
                    if task["enabled"] and not in_window:
                        # ä»»åŠ¡å·²å¯ç”¨ä½†ä¸åœ¨æ—¶é—´çª—å†…ï¼Œè‡ªåŠ¨ç¦ç”¨
                        task["enabled"] = False
                        logger.info(f"â¸ï¸ Task {task['id']} auto-disabled (out of window {task.get('start_time')}~{task.get('end_time')})")
                        # åŒæ­¥åˆ°é…ç½®å’Œ state
                        self.client_pool.update_tasks_config(self.tasks)
                        # åŒæ­¥åˆ° state.jsonï¼ˆå¦‚æœå¯ç”¨ï¼‰
                        if self.state_store:
                            asyncio.create_task(self._sync_state_enabled(task["id"], False))
                    elif not task["enabled"] and in_window:
                        # ä»»åŠ¡å·²ç¦ç”¨ä½†åœ¨æ—¶é—´çª—å†…ï¼Œè‡ªåŠ¨å¯ç”¨
                        task["enabled"] = True
                        task["next_run"] = now  # ç«‹å³å¯ä»¥è¿è¡Œ
                        logger.info(f"â–¶ï¸ Task {task['id']} auto-enabled (in window {task.get('start_time')}~{task.get('end_time')})")
                        # åŒæ­¥åˆ°é…ç½®å’Œ state
                        self.client_pool.update_tasks_config(self.tasks)
                        # åŒæ­¥åˆ° state.jsonï¼ˆå¦‚æœå¯ç”¨ï¼‰
                        if self.state_store:
                            asyncio.create_task(self._sync_state_enabled(task["id"], True))
                
                if not task["enabled"]:
                    continue
                
                # æ£€æŸ¥æ—¶é—´çª—ï¼ˆåœ¨è°ƒåº¦æ—¶ä¹Ÿæ£€æŸ¥ï¼Œé¿å…åœ¨æ—¶é—´çª—å¤–è®¾ç½® next_runï¼‰
                if not self._is_in_time_window(task):
                    # å¦‚æœä¸åœ¨æ—¶é—´çª—å†…ï¼Œé‡ç½® next_run ä¸ºæ—¶é—´çª—å¼€å§‹æ—¶é—´
                    if task.get("start_time"):
                        try:
                            h, m = task["start_time"].split(":")
                            start_minutes = int(h) * 60 + int(m)
                            now_dt = datetime.now(TZ_SHANGHAI)
                            now_minutes = now_dt.hour * 60 + now_dt.minute
                            
                            # è®¡ç®—ä¸‹æ¬¡è¿è¡Œæ—¶é—´ï¼ˆæ—¶é—´çª—å¼€å§‹æ—¶é—´ï¼‰
                            if now_minutes < start_minutes:
                                # ä»Šå¤©çš„æ—¶é—´çª—è¿˜æ²¡å¼€å§‹
                                next_run_dt = now_dt.replace(hour=int(h), minute=int(m), second=0, microsecond=0)
                            else:
                                # ä»Šå¤©çš„æ—¶é—´çª—å·²è¿‡ï¼Œè®¾ç½®ä¸ºæ˜å¤©çš„æ—¶é—´çª—å¼€å§‹æ—¶é—´
                                next_run_dt = (now_dt + timedelta(days=1)).replace(hour=int(h), minute=int(m), second=0, microsecond=0)
                            
                            task["next_run"] = next_run_dt.timestamp()
                            logger.debug(f"â¸ï¸ Task {task['id']} out of window, next run at window start: {next_run_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                        except Exception as e:
                            logger.warning(f"âš ï¸ Failed to calculate next run for task {task['id']}: {e}")
                    continue
                
                if now >= task["next_run"]:
                    # åœ¨æ‰§è¡Œå‰å†æ¬¡æ£€æŸ¥æ—¶é—´çª—ï¼ˆåŒé‡æ£€æŸ¥ï¼‰
                    if not self._is_in_time_window(task):
                        # å¦‚æœä¸åœ¨æ—¶é—´çª—å†…ï¼Œè®¡ç®—ä¸‹æ¬¡è¿è¡Œæ—¶é—´
                        if task.get("start_time"):
                            try:
                                h, m = task["start_time"].split(":")
                                start_minutes = int(h) * 60 + int(m)
                                now_dt = datetime.now(TZ_SHANGHAI)
                                now_minutes = now_dt.hour * 60 + now_dt.minute
                                
                                # è®¡ç®—ä¸‹æ¬¡è¿è¡Œæ—¶é—´ï¼ˆæ—¶é—´çª—å¼€å§‹æ—¶é—´ï¼‰
                                if now_minutes < start_minutes:
                                    # ä»Šå¤©çš„æ—¶é—´çª—è¿˜æ²¡å¼€å§‹
                                    next_run_dt = now_dt.replace(hour=int(h), minute=int(m), second=0, microsecond=0)
                                else:
                                    # ä»Šå¤©çš„æ—¶é—´çª—å·²è¿‡ï¼Œè®¾ç½®ä¸ºæ˜å¤©çš„æ—¶é—´çª—å¼€å§‹æ—¶é—´
                                    next_run_dt = (now_dt + timedelta(days=1)).replace(hour=int(h), minute=int(m), second=0, microsecond=0)
                                
                                task["next_run"] = next_run_dt.timestamp()
                                logger.info(f"â¸ï¸ Task {task['id']} skipped (out of window), next run at: {next_run_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                            except Exception as e:
                                logger.warning(f"âš ï¸ Failed to calculate next run for task {task['id']}: {e}")
                        continue
                    
                    # åœ¨æ—¶é—´çª—å†…ï¼Œæ­£å¸¸æ‰§è¡Œ
                    task["next_run"] = now + task["interval_minutes"] * 60
                    # è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¶é—´ï¼ˆä½¿ç”¨ä¸­å›½æ—¶åŒºï¼‰
                    next_run_dt = datetime.fromtimestamp(task["next_run"], tz=TZ_SHANGHAI)
                    logger.info(f"â° Task {task['id']} next run: {next_run_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                    asyncio.create_task(self._run_task(task))
            await asyncio.sleep(3)
    
    async def _run_state_watcher(self):
        """åå°è½®è¯¢ state.json æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´ï¼Œè‹¥å˜åŒ–åˆ™åŒæ­¥åˆ° scheduler å†…å­˜"""
        if not self.state_store:
            return
        path = self.state_store.path
        try:
            if path.exists():
                self._state_mtime = path.stat().st_mtime
        except Exception:
            self._state_mtime = None

        while True:
            try:
                await asyncio.sleep(3)
                try:
                    if not path.exists():
                        continue
                    mtime = path.stat().st_mtime
                except Exception:
                    continue
                if self._state_mtime is None or mtime != self._state_mtime:
                    self._state_mtime = mtime
                    logger.info(f"ğŸ”„ Detected state.json change, syncing tasks to scheduler...")
                    try:
                        await self._sync_tasks_from_state()
                    except Exception as e:
                        logger.warning(f"âš ï¸ Failed to sync tasks from state: {e}")
            except asyncio.CancelledError:
                break
            except Exception:
                # å¿½ç•¥å•è½®é”™è¯¯ï¼Œç»§ç»­å¾ªç¯
                continue

    async def _sync_tasks_from_state(self):
        """ä» StateStore è¯»å–ä»»åŠ¡é…ç½®å¹¶åŒæ­¥åˆ° scheduler.tasksï¼ˆä»…æ›´æ–°å­˜åœ¨çš„ä»»åŠ¡ï¼‰"""
        if not self.state_store:
            return
        tasks_cfg = await self.state_store.all_tasks()
        if not tasks_cfg:
            return

        # tasks_cfg æ˜¯ dict {task_id: {enabled, listen_chats, push_chats, filters, start_time, end_time}}
        # æ›´æ–° self.tasks ä¸­å·²å­˜åœ¨çš„ä»»åŠ¡
        updated = 0
        for t in self.tasks:
            tid = t.get("id")
            if tid and tid in tasks_cfg:
                cfg = tasks_cfg[tid]
                t["start_time"] = cfg.get("start_time")
                t["end_time"] = cfg.get("end_time")
                # åŒæ­¥ enabled å­—æ®µï¼ˆç®¡ç†å‘˜æ‰‹åŠ¨è®¾ç½®ï¼‰
                t["enabled"] = bool(cfg.get("enabled", t.get("enabled", True)))

                # é‡æ–°è®¡ç®— next_run/å¯ç”¨çŠ¶æ€æ ¹æ®æ—¶é—´çª—
                try:
                    in_window = self._is_in_time_window(t)
                except Exception:
                    in_window = True
                if in_window and t.get("enabled", False):
                    t["next_run"] = time.time()
                else:
                    # å¦‚æœä¸åœ¨æ—¶é—´çª—å†…ï¼Œè®¾ç½® next_run ä¸ºæ—¶é—´çª—å¼€å§‹
                    try:
                        st = t.get("start_time")
                        if st:
                            h, m = st.split(":")
                            from datetime import datetime as _dt, timedelta as _td
                            now_dt = _dt.now(TZ_SHANGHAI)
                            candidate = now_dt.replace(hour=int(h), minute=int(m), second=0, microsecond=0)
                            if candidate <= now_dt:
                                candidate = candidate + _td(days=1)
                            t["next_run"] = candidate.timestamp()
                        else:
                            t["next_run"] = time.time()
                    except Exception:
                        t["next_run"] = time.time()
                updated += 1

        if updated > 0:
            logger.info(f"âœ… Synchronized {updated} task(s) from state.json")
            # å†™å› client pool config
            try:
                self.client_pool.update_tasks_config(self.tasks)
            except Exception:
                pass
    
    def _is_in_time_window(self, task: Dict[str, Any]) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦åœ¨æ—¶é—´çª—å†…"""
        if not task.get("start_time") and not task.get("end_time"):
            return True  # æ²¡æœ‰è®¾ç½®æ—¶é—´çª—ï¼Œå§‹ç»ˆå…è®¸
        
        now_dt = datetime.now(TZ_SHANGHAI)
        now_minutes = now_dt.hour * 60 + now_dt.minute
        start_minutes = None
        end_minutes = None

        try:
            if task.get("start_time"):
                st = str(task.get("start_time")).strip()
                h, m = st.split(":")
                start_minutes = int(h) * 60 + int(m)
            if task.get("end_time"):
                en = str(task.get("end_time")).strip()
                h, m = en.split(":")
                end_minutes = int(h) * 60 + int(m)
        except Exception:
            logger.warning(
                "âš ï¸ Invalid start/end time format for task %s: %s - %s",
                task.get("id"),
                task.get("start_time"),
                task.get("end_time"),
            )
            # é¿å…å› æ ¼å¼é—®é¢˜é˜»å¡ä»»åŠ¡ï¼Œè¿”å› True å…è®¸æ‰§è¡Œ
            return True

        # è®°å½•è°ƒè¯•ä¿¡æ¯ï¼Œä¾¿äºæ’æŸ¥è‡ªåŠ¨å¯åœé—®é¢˜
        logger.debug(
            "Time window check task=%s now=%02d:%02d start=%s(%s) end=%s(%s)",
            task.get("id"),
            now_dt.hour,
            now_dt.minute,
            task.get("start_time"),
            f"{start_minutes}" if start_minutes is not None else "None",
            task.get("end_time"),
            f"{end_minutes}" if end_minutes is not None else "None",
        )

        # åˆ¤æ–­æ˜¯å¦åœ¨æ—¶é—´çª—å†…ï¼ˆæ”¯æŒè·¨å¤©ï¼‰
        if start_minutes is not None and end_minutes is not None:
            if start_minutes <= end_minutes:
                return start_minutes <= now_minutes <= end_minutes
            else:
                return now_minutes >= start_minutes or now_minutes <= end_minutes
        elif start_minutes is not None:
            return now_minutes >= start_minutes
        elif end_minutes is not None:
            return now_minutes <= end_minutes
        else:
            return True

    async def _run_task(self, task: Dict[str, Any]):
        # å†æ¬¡æ£€æŸ¥æ—¶é—´çª—ï¼ˆåŒé‡æ£€æŸ¥ï¼Œç¡®ä¿åœ¨æ—¶é—´çª—å†…ï¼‰
        if not self._is_in_time_window(task):
            logger.info(f"â¸ï¸ Task {task['id']} skipped (out of window {task.get('start_time')}~{task.get('end_time')})")
            return

        client_name = task["client"]
        client = self.client_pool.get_client(client_name)
        if not client:
            logger.warning(f"âš ï¸ Client not found for task {task['id']}: {client_name}")
            return

        chain = task["chain"]
        ca = task["ca"]
        targets = task["targets"]

        # è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¶é—´ï¼ˆä½¿ç”¨ä¸­å›½æ—¶åŒºï¼‰
        run_time = datetime.now(TZ_SHANGHAI)
        logger.info(f"â–¶ï¸ Task {task['id']} running at {run_time.strftime('%Y-%m-%d %H:%M:%S %Z')}: {chain} {ca[:8]}..., targets={len(targets)}")
        try:
            photo, caption, error_msg = await self.process_ca(chain, ca, True, task_id=task.get("id"))
            if error_msg:
                msg = f"âŒ ä»»åŠ¡ {task['name']} å¤±è´¥ï¼š{error_msg}"
                await self._send_to_targets(client, targets, text=msg, ca=ca)
                return
            if not caption:
                await self._send_to_targets(client, targets, text=f"âŒ ä»»åŠ¡ {task['name']} æ— è¿”å›æ•°æ®", ca=ca)
                return
            await self._send_to_targets(client, targets, text=caption, photo=photo, ca=ca)
            logger.info(f"âœ… Task {task['id']} sent to {len(targets)} targets")
        except Exception as e:
            logger.warning(f"âš ï¸ Task {task['id']} error: {e}")

    async def _send_to_targets(self, client, targets: List[Any], text: Optional[str] = None, photo=None, ca: Optional[str] = None):
        for target in targets:
            try:
                is_bot = isinstance(target, str) and target.startswith("@")
                if is_bot:
                    # å¯¹æœºå™¨äººä»…å‘é€ CAï¼ˆè‹¥æä¾›ï¼‰ï¼Œå¦åˆ™å‘é€æ–‡æœ¬
                    payload = ca or text or ""
                    if photo:
                        if hasattr(photo, "seek"):
                            photo.seek(0)
                        await client.send_file(target, photo, caption=payload, parse_mode="html")
                    else:
                        await client.send_message(target, payload, parse_mode="html")
                else:
                    if photo:
                        if hasattr(photo, "seek"):
                            photo.seek(0)
                        await client.send_file(target, photo, caption=text or "", parse_mode="html")
                    else:
                        if text:
                            await client.send_message(target, text, parse_mode="html")
            except RPCError as e:
                logger.warning(f"âš ï¸ Send failed to {target}: {e}")
            except Exception as e:
                logger.warning(f"âš ï¸ Send failed to {target}: {e}")
    
    async def _sync_state_enabled(self, task_id: str, enabled: bool):
        """å¼‚æ­¥åŒæ­¥ä»»åŠ¡å¯ç”¨çŠ¶æ€åˆ° state.json"""
        try:
            if self.state_store:
                await self.state_store.set_task_enabled(task_id, enabled)
        except Exception as e:
            logger.warning(f"âš ï¸ Failed to sync task {task_id} enabled status to state: {e}")


--- File: ./src/client_pool.py ---
from __future__ import annotations

import asyncio
import json
import logging
import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from telethon import TelegramClient
from telethon.sessions import StringSession

logger = logging.getLogger("ca_filter_bot.client_pool")


class ClientConfigError(RuntimeError):
    pass


class ClientPool:
    """
    ç®€å•çš„ MTProto å®¢æˆ·ç«¯æ± ï¼ŒåŸºäº Telethonã€‚
    ä» config/tasks.json è¯»å– client é…ç½®å¹¶å¯åŠ¨ã€‚
    """

    def __init__(self, config_path: str):
        self.config_path = Path(config_path)
        self.clients: Dict[str, TelegramClient] = {}
        # ç¼“å­˜å®¢æˆ·ç«¯è´¦å·ä¿¡æ¯ï¼ˆusername / idï¼‰ï¼Œç”¨äºå±•ç¤ºå‹å¥½çš„åç§°
        self.client_meta: Dict[str, Dict[str, Any]] = {}
        self._tasks_cfg: List[dict] = []
        self._clients_cfg: List[dict] = []
        self.default_api_id: Optional[int] = None
        self.default_api_hash: Optional[str] = None

    async def load(self) -> None:
        if not self.config_path.exists():
            logger.warning(f"âš ï¸ tasks config not found: {self.config_path}")
            return
        try:
            data = json.loads(self.config_path.read_text(encoding="utf-8"))
        except Exception as e:
            raise ClientConfigError(f"Failed to load tasks config: {e}") from e

        # è¯»å–é»˜è®¤ app id/hashï¼ˆä»…ä»ç¯å¢ƒå˜é‡ï¼‰
        self.default_api_id = self._env_int("TELEGRAM_API_ID") or self._env_int("APP_ID")
        self.default_api_hash = os.getenv("TELEGRAM_API_HASH") or os.getenv("APP_HASH")
        if not self.default_api_id or not self.default_api_hash:
            raise ClientConfigError("ç¯å¢ƒå˜é‡ TELEGRAM_API_ID / TELEGRAM_API_HASH æœªé…ç½®ï¼ˆæˆ– APP_ID / APP_HASHï¼‰")

        self._clients_cfg = data.get("clients", [])
        self._tasks_cfg = data.get("tasks", [])

        # æ¸…ç†é…ç½®ä¸­çš„api_idå’Œapi_hashï¼ˆç»Ÿä¸€ä½¿ç”¨.envä¸­çš„é»˜è®¤å€¼ï¼‰
        cleaned_clients = []
        for cfg in self._clients_cfg:
            name = cfg.get("name")
            session = cfg.get("session") or ""
            
            if not name:
                logger.warning(f"âš ï¸ Invalid client config (ç¼ºå°‘name): {cfg}")
                continue
            
            # éªŒè¯sessionæ˜¯å¦æœ‰æ•ˆ
            session_type = self._detect_session_type(session)
            if session_type == "unknown":
                logger.warning(f"âš ï¸ è·³è¿‡æ— æ•ˆçš„å®¢æˆ·ç«¯é…ç½®ï¼ˆæ— æ³•è¯†åˆ«sessionç±»å‹ï¼‰: {name}")
                continue
            
            # ç»Ÿä¸€ä½¿ç”¨é»˜è®¤çš„api_idå’Œapi_hash
            api_id = self.default_api_id
            api_hash = self.default_api_hash
            
            if name in self.clients:
                logger.debug(f"Skipping duplicate client name: {name}")
                continue
            
            # æ¸…ç†é…ç½®ï¼Œåªä¿ç•™nameå’Œsession
            cleaned_cfg = {"name": name, "session": session}
            cleaned_clients.append(cleaned_cfg)
            
            try:
                client = self._create_client(session, int(api_id), api_hash)
                await client.start()
                self.clients[name] = client
                # è·å–è´¦å·ä¿¡æ¯å¹¶ç¼“å­˜
                try:
                    me = await client.get_me()
                    username = getattr(me, "username", None)
                    user_id = getattr(me, "id", None)
                    display_name = username or f"user_{user_id}" if user_id is not None else name
                    self.client_meta[name] = {
                        "username": username,
                        "id": user_id,
                        "display_name": display_name,
                    }
                    logger.info(f"âœ… Client started: {name} (username={username}, id={user_id})")
                except Exception as e:
                    logger.warning(f"âš ï¸ Failed to fetch client info for {name}: {e}")
                    self.client_meta[name] = {"username": None, "id": None, "display_name": name}
            except Exception as e:
                logger.warning(f"âš ï¸ Failed to start client {name}: {e}")
        
        # ä¿å­˜æ¸…ç†åçš„é…ç½®
        if cleaned_clients != self._clients_cfg:
            self._clients_cfg = cleaned_clients
            self._save()

        if not self.clients:
            logger.warning("âš ï¸ No MTProto clients started; tasks needing client will be skipped")

    def get_client(self, name: str) -> Optional[TelegramClient]:
        return self.clients.get(name)

    def tasks_config(self) -> List[dict]:
        return self._tasks_cfg

    def clients_config(self) -> List[dict]:
        return self._clients_cfg

    def _save(self):
        data = {
            "clients": self._clients_cfg,
            "tasks": self._tasks_cfg,
        }
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        self.config_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

    def _env_int(self, key: str) -> Optional[int]:
        try:
            val = os.getenv(key)
            return int(val) if val else None
        except Exception:
            return None

    async def add_client(self, name: Optional[str], session: str) -> str:
        """
        æ·»åŠ å®¢æˆ·ç«¯å¹¶è¿”å›æœ€ç»ˆä½¿ç”¨çš„åç§°ã€‚
        å¦‚æœæœªä¼ å…¥ nameï¼Œåˆ™è‡ªåŠ¨ä½¿ç”¨è´¦å·çš„ usernameï¼ˆæˆ– user_idï¼‰ä½œä¸ºåç§°ã€‚
        """
        # ç¡®ä¿é»˜è®¤ APP_ID/APP_HASH å·²ä»ç¯å¢ƒå˜é‡åŠ è½½ï¼ˆå³ä½¿ tasks.json ä¸å­˜åœ¨ä¹Ÿèƒ½æ­£å¸¸æ·»åŠ ï¼‰
        if not self.default_api_id or not self.default_api_hash:
            self.default_api_id = self.default_api_id or self._env_int("TELEGRAM_API_ID") or self._env_int("APP_ID")
            self.default_api_hash = self.default_api_hash or os.getenv("TELEGRAM_API_HASH") or os.getenv("APP_HASH")
        if not self.default_api_id or not self.default_api_hash:
            raise ClientConfigError("é»˜è®¤ APP_ID/APP_HASH æœªé…ç½®ï¼Œè¯·åœ¨ .env è®¾ç½® TELEGRAM_API_ID / TELEGRAM_API_HASH")
        
        # éªŒè¯sessionæ˜¯å¦æœ‰æ•ˆ
        session_type = self._detect_session_type(session)
        if not session or session_type == "unknown":
            raise ValueError(f"æ— æ•ˆçš„sessionï¼šæ— æ³•è¯†åˆ«sessionç±»å‹ï¼ˆæ–‡ä»¶è·¯å¾„æˆ–string sessionï¼‰")
        
        # å…ˆå°è¯•åˆ›å»ºå’Œå¯åŠ¨å®¢æˆ·ç«¯
        try:
            client = self._create_client(session, int(self.default_api_id), self.default_api_hash)
            await client.start()
            # è·å–è´¦å·ä¿¡æ¯ç”¨äºè‡ªåŠ¨å‘½å
            try:
                me = await client.get_me()
                auto_base = getattr(me, "username", None) or f"user_{getattr(me, 'id', '')}".strip("_")
            except Exception:
                auto_base = None
        except Exception as e:
            logger.error(f"âŒ Failed to start client {name or '[auto]'}: {e}")
            raise  # é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œè®©è°ƒç”¨è€…çŸ¥é“å¤±è´¥åŸå› 
        
        # ç¡®å®šæœ€ç»ˆåç§°ï¼šä¼˜å…ˆç”¨æˆ·è¾“å…¥ï¼Œå…¶æ¬¡ usernameï¼Œå†æ¬¡ user_idï¼Œæœ€åå›é€€ client
        base_name = name or auto_base or "client"
        final_name = base_name
        idx = 1
        # é¿å…ä¸å·²æœ‰å®¢æˆ·ç«¯/é…ç½®é‡å
        existing_names = {c.get("name") for c in self._clients_cfg} | set(self.clients.keys())
        while final_name in existing_names:
            idx += 1
            final_name = f"{base_name}_{idx}"
        
        # ä¿å­˜å®¢æˆ·ç«¯åˆ°å†…å­˜
        self.clients[final_name] = client
        # ç¼“å­˜è´¦å·ä¿¡æ¯ç”¨äºå±•ç¤º
        try:
            if 'me' not in locals():
                me = await client.get_me()
            username = getattr(me, "username", None)
            user_id = getattr(me, "id", None)
            display_name = username or f"user_{user_id}" if user_id is not None else final_name
            self.client_meta[final_name] = {
                "username": username,
                "id": user_id,
                "display_name": display_name,
            }
            logger.info(f"âœ… Client started: {final_name} (username={username}, id={user_id})")
        except Exception as e:
            logger.warning(f"âš ï¸ Failed to fetch client info for {final_name}: {e}")
            self.client_meta[final_name] = {"username": None, "id": None, "display_name": final_name}
        
        # å®¢æˆ·ç«¯å¯åŠ¨æˆåŠŸåï¼Œæ‰ä¿å­˜åˆ°é…ç½®
        cfg = {"name": final_name, "session": session}
        self._clients_cfg.append(cfg)
        self._save()
        logger.info(f"âœ… Client {final_name} added to config")
        return final_name

    async def remove_client(self, name: str) -> bool:
        """åˆ é™¤å®¢æˆ·ç«¯"""
        removed = False
        
        # åœæ­¢å¹¶æ–­å¼€å®¢æˆ·ç«¯è¿æ¥
        if name in self.clients:
            try:
                await self.clients[name].disconnect()
                del self.clients[name]
                logger.info(f"âœ… Client disconnected: {name}")
                removed = True
            except Exception as e:
                logger.warning(f"âš ï¸ Failed to disconnect client {name}: {e}")
                # å³ä½¿æ–­å¼€å¤±è´¥ï¼Œä¹Ÿä»å†…å­˜ä¸­åˆ é™¤
                if name in self.clients:
                    del self.clients[name]
                    removed = True
        
        # ä»é…ç½®ä¸­åˆ é™¤
        original_count = len(self._clients_cfg)
        self._clients_cfg = [c for c in self._clients_cfg if c.get("name") != name]
        
        if len(self._clients_cfg) < original_count:
            self._save()
            logger.info(f"âœ… Client removed from config: {name}")
            removed = True
        
        if not removed:
            logger.warning(f"âš ï¸ Client {name} not found in memory or config")
        
        return removed

    def describe_clients(self) -> List[Dict[str, Any]]:
        """è¿”å›å®¢æˆ·ç«¯è¯¦ç»†ä¿¡æ¯ï¼Œç”¨äºå‰ç«¯å±•ç¤º"""
        desc = []
        for cfg in self._clients_cfg:
            name = cfg.get("name")
            session = cfg.get("session") or ""
            
            # æ£€æµ‹sessionç±»å‹ï¼Œå¦‚æœæ— æ³•è¯†åˆ«åˆ™è·³è¿‡
            session_type = self._detect_session_type(session)
            if session_type == "unknown":
                logger.warning(f"âš ï¸ è·³è¿‡æ— æ•ˆçš„å®¢æˆ·ç«¯é…ç½®ï¼ˆæ— æ³•è¯†åˆ«sessionç±»å‹ï¼‰: {name}")
                continue
            
            # ç»Ÿä¸€ä½¿ç”¨.envä¸­çš„é»˜è®¤api_id
            api_id = self.default_api_id
            session_preview = self._mask_session(session, session_type)
            
            # ä¸­æ–‡çŠ¶æ€
            status = "è¿è¡Œä¸­" if name in self.clients else "å·²åœæ­¢"
            
            # ä¸­æ–‡sessionç±»å‹
            session_type_cn = "æ–‡ä»¶" if session_type == "file" else "å­—ç¬¦ä¸²"
            
            meta = self.client_meta.get(name, {})
            display_name = meta.get("display_name") or name
            username = meta.get("username")
            user_id = meta.get("id")
            
            desc.append({
                "name": display_name,
                "internal_name": name,
                "username": username,
                "user_id": user_id,
                "api_id": api_id,
                "session_type": session_type_cn,
                "session_preview": session_preview,
                "status": status,
            })
        return desc
    
    def _detect_session_type(self, session: str) -> str:
        """æ£€æµ‹sessionç±»å‹ï¼šfile æˆ– string æˆ– unknown"""
        if not session or not session.strip():
            return "unknown"
        session = session.strip()
        
        # å¦‚æœsessionå¾ˆé•¿ï¼ˆ>255å­—ç¬¦ï¼‰ï¼Œå¾ˆå¯èƒ½æ˜¯string session
        if len(session) > 255:
            return "string"
        
        # å¦‚æœåŒ…å«è·¯å¾„åˆ†éš”ç¬¦ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶è·¯å¾„
        if "/" in session or "\\" in session:
            try:
                if Path(session).exists():
                    return "file"
            except (OSError, ValueError):
                # æ–‡ä»¶è·¯å¾„å¤ªé•¿æˆ–å…¶ä»–é”™è¯¯ï¼Œæ— æ³•è¯†åˆ«
                return "unknown"
        
        # å¦‚æœä»¥.sessionç»“å°¾ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶è·¯å¾„
        if session.endswith(".session"):
            try:
                if Path(session).exists():
                    return "file"
            except (OSError, ValueError):
                return "unknown"
        
        # å¦‚æœsessioné•¿åº¦åˆç†ï¼ˆ>10å­—ç¬¦ï¼‰ï¼Œå¯èƒ½æ˜¯string session
        if len(session) > 10:
            return "string"
        
        # æ— æ³•è¯†åˆ«
        return "unknown"

    def _create_client(self, session: str, api_id: int, api_hash: str) -> TelegramClient:
        """æ”¯æŒ session æ–‡ä»¶è·¯å¾„æˆ– session å­—ç¬¦ä¸²"""
        # å…ˆæ£€æµ‹ session ç±»å‹ï¼Œé¿å…å¯¹é•¿å­—ç¬¦ä¸²è°ƒç”¨ Path().exists()
        session_type = self._detect_session_type(session)
        
        if session_type == "file":
            # æ–‡ä»¶è·¯å¾„
            return TelegramClient(session=str(session), api_id=int(api_id), api_hash=api_hash)
        elif session_type == "string":
            # å­—ç¬¦ä¸² session
            return TelegramClient(session=StringSession(session), api_id=int(api_id), api_hash=api_hash)
        else:
            # æœªçŸ¥ç±»å‹ï¼Œå°è¯•ä½œä¸ºå­—ç¬¦ä¸²å¤„ç†
            logger.warning(f"âš ï¸ Unknown session type, treating as string session")
            return TelegramClient(session=StringSession(session), api_id=int(api_id), api_hash=api_hash)

    def _mask_session(self, session: str, session_type: str) -> str:
        if session_type == "file":
            return str(Path(session))
        if len(session) <= 12:
            return session
        return f"{session[:6]}...{session[-6:]}"

    def update_tasks_config(self, tasks: List[dict]):
        self._tasks_cfg = tasks
        self._save()

    async def stop(self) -> None:
        for name, client in self.clients.items():
            try:
                await client.disconnect()
                logger.info(f"âœ… Client stopped: {name}")
            except Exception as e:
                logger.warning(f"âš ï¸ Failed to stop client {name}: {e}")


--- File: ./src/solana_analyzer.py ---
from __future__ import annotations

import asyncio
import logging
from collections import defaultdict
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from .models import ChainConfig

logger = logging.getLogger("ca_filter_bot.solana_analyzer")

# æ’é™¤åå• (DEX, Router, Burn, MEV)
# é‡åˆ°è¿™äº›åœ°å€ä½œä¸º Sender æ—¶ï¼Œä¸è§†ä¸ºè€é¼ ä»“åˆ†å‘æº
WHITELIST = {
    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5wDbuXB",  # Raydium Authority
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",  # Token Program
    "11111111111111111111111111111111",  # System Program
    "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4",  # Jupiter
    "TSLvdd1pWpHVjahSpsvCXUbgwsL3JAcvokwaKt1eokM",  # Tensor / Marketplace
    "So11111111111111111111111111111111111111112",  # SOL
    "SysvarRent111111111111111111111111111111111",  # Rent Sysvar
    "SysvarC1ock11111111111111111111111111111111",  # Clock Sysvar
}

# å¹¶å‘é™åˆ¶ (é˜²æ­¢ RPC 429 æŠ¥é”™)
SEM = asyncio.Semaphore(10)


class SolanaRoughAnalyzer:
    """
    ä½¿ç”¨èµ„é‡‘åŒæºåˆ†æï¼ˆFunding Source Traceï¼‰è®¡ç®—è€é¼ ä»“å’Œæ†ç»‘å æ¯”
    æ ¸å¿ƒæ€è·¯ï¼šä»"çŒœæ—¶é—´"å‡çº§åˆ°"æŸ¥èµ„é‡‘"
    - Level 1: æŠ“å–å¼€ç›˜å‰äº¤æ˜“ï¼Œæ‰¾å‡ºæ—©æœŸä¹°å…¥è€…
    - Level 2: å¯¹è¿™äº›å¯ç–‘åœ°å€ï¼ŒæŸ¥å®ƒä»¬çš„ç¬¬ä¸€ç¬”SOLæ˜¯è°è½¬è¿›æ¥çš„
    - Level 3: è‡ªåŠ¨å‰”é™¤DEXã€Routerã€MEV Botç­‰å¹²æ‰°é¡¹
    """

    def __init__(self, rpc_url: str, client):
        self.rpc_url = rpc_url
        self.client = client

    async def _rpc_call(self, method: str, params: list) -> Optional[dict]:
        """å¼‚æ­¥RPCè°ƒç”¨ï¼Œå¸¦å¹¶å‘é™åˆ¶"""
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": method,
            "params": params
        }
        async with SEM:  # é™åˆ¶å¹¶å‘
            try:
                r = await self.client.post(self.rpc_url, json=payload, timeout=15)
                if r.status_code == 200:
                    return r.json().get("result")
            except Exception as e:
                logger.debug(f"RPC call failed {method}: {e}")
            return None

    async def _get_token_supply(self, mint_address: str) -> float:
        """è·å–ä»£å¸æ€»ä¾›åº”é‡"""
        data = await self._rpc_call("getTokenSupply", [mint_address])
        if data and 'value' in data:
            amount = float(data['value']['amount'])
            decimals = data['value'].get('decimals', 9)
            return amount / (10 ** decimals)
        return 0.0

    async def _get_largest_accounts(self, mint_address: str, limit: int = 20) -> List[dict]:
        """è·å–å‰NåæŒä»“å¤§æˆ·"""
        data = await self._rpc_call("getTokenLargestAccounts", [mint_address])
        if data and 'value' in data:
            return data['value'][:limit]
        return []

    async def _get_account_owner(self, pubkey: str) -> Optional[str]:
        """è§£æ Token Account çš„çœŸæ­£ Owner"""
        data = await self._rpc_call("getAccountInfo", [pubkey, {"encoding": "jsonParsed"}])
        try:
            result = data.get("value")
            if not result:
                return None
            parsed = result.get("data", {}).get("parsed", {})
            info = parsed.get("info", {})
            return info.get("owner")
        except:
            return None

    async def _get_signatures(self, address: str, limit: int = 200, before: Optional[str] = None) -> List[dict]:
        """è·å–åœ°å€çš„äº¤æ˜“ç­¾ååˆ—è¡¨"""
        params = [address, {"limit": limit}]
        if before:
            params[1]["before"] = before
        return await self._rpc_call("getSignaturesForAddress", params) or []

    async def _get_parsed_tx(self, signature: str) -> Optional[dict]:
        """è·å–è§£æåçš„äº¤æ˜“è¯¦æƒ…"""
        return await self._rpc_call(
            "getTransaction",
            [signature, {"encoding": "jsonParsed", "maxSupportedTransactionVersion": 0}]
        )

    async def _analyze_funding_source(self, wallets: List[str]) -> Dict[str, List[str]]:
        """
        ğŸ•µï¸â€â™‚ï¸ èµ„é‡‘æº¯æºï¼ˆé«˜å‡†ç¡®åº¦æ ¸å¿ƒï¼‰
        æŸ¥è¿™äº›é’±åŒ…çš„ç¬¬ä¸€ç¬”äº¤æ˜“ï¼Œçœ‹ SOL æ˜¯è°ç»™çš„ã€‚
        è¿”å›: {funding_source: [wallet1, wallet2, ...]}
        """
        funding_map = defaultdict(list)

        async def check_one(wallet: str):
            try:
                # æŸ¥æœ€è¿‘50ç¬”äº¤æ˜“ï¼ˆå‡è®¾æ˜¯æ–°é’±åŒ…ï¼Œç¬¬ä¸€ç¬”é€šå¸¸åœ¨æœ€è¿‘50ç¬”å†…ï¼‰
                sigs = await self._get_signatures(wallet, limit=50)
                if not sigs:
                    return

                # å–æœ€æ—©çš„ä¸€ç¬”ï¼ˆé€šå¸¸æ˜¯ Funding æˆ–ç¬¬ä¸€ç¬”ä¹°å…¥ï¼‰
                earliest_sig = sigs[-1]["signature"]
                tx = await self._get_parsed_tx(earliest_sig)

                if not tx:
                    return

                # åˆ†æè°è½¬è´¦ç»™äº†è¿™ä¸ªé’±åŒ… SOL
                # æŸ¥æ‰¾ SystemProgram Transfer
                try:
                    transaction = tx.get("transaction", {})
                    message = transaction.get("message", {})
                    instructions = message.get("instructions", [])

                    sender = "Unknown"
                    for instr in instructions:
                        parsed = instr.get("parsed", {})
                        if parsed.get("type") == "transfer" and parsed.get("program") == "system":
                            info = parsed.get("info", {})
                            if info.get("destination") == wallet:
                                sender = info.get("source")
                                break

                    if sender != "Unknown" and sender not in WHITELIST:
                        funding_map[sender].append(wallet)
                        logger.debug(f"  ğŸ’° {wallet[:8]}... funded by {sender[:8]}...")
                except Exception as e:
                    logger.debug(f"  âš ï¸ Failed to parse funding for {wallet[:8]}: {e}")
            except Exception as e:
                logger.debug(f"  âš ï¸ Error checking funding for {wallet[:8]}: {e}")

        # å¹¶å‘æ£€æŸ¥æ‰€æœ‰é’±åŒ…
        await asyncio.gather(*[check_one(w) for w in wallets])
        return funding_map

    async def analyze(self, mint_address: str) -> Tuple[Optional[float], Optional[float]]:
        """
        åˆ†æä»£å¸ï¼Œè¿”å› (bundled_ratio, rat_ratio)
        è¿”å›å€¼ä¸ºå°æ•°å½¢å¼ï¼ˆ0.23 = 23%ï¼‰
        """
        try:
            logger.info(f"ğŸ” Starting funding source trace analysis for {mint_address[:8]}...")

            # 1. è·å–æ€»ä¾›åº”é‡
            total_supply = await self._get_token_supply(mint_address)
            if total_supply == 0:
                logger.warning("Cannot get token supply")
                return None, None

            # 2. è·å–æ—©æœŸäº¤æ˜“ï¼ˆå¯»æ‰¾å¼€ç›˜ç¬é—´ï¼‰
            logger.debug("  - æ­£åœ¨æŠ“å–æ—©æœŸäº¤æ˜“...")
            sigs = await self._get_signatures(mint_address, limit=300)
            if not sigs:
                logger.warning("  âŒ æ— æ³•è·å–äº¤æ˜“æ•°æ®")
                return None, None

            # å€’åºï¼Œæ‰¾åˆ°å¼€ç›˜é‚£å‡ ç¬”
            sigs.sort(key=lambda x: x.get("blockTime", 0))
            launch_time = sigs[0].get("blockTime", 0) if sigs else 0
            if launch_time == 0:
                logger.warning("  âŒ æ— æ³•ç¡®å®šå¼€ç›˜æ—¶é—´")
                return None, None

            logger.debug(f"  - å‘ç°å¼€ç›˜æ—¶é—´æˆ³: {launch_time} ({datetime.fromtimestamp(launch_time)})")

            # 3. è§£æå‰100ç¬”äº¤æ˜“ï¼Œæå–ä¹°å…¥è€…ï¼ˆå¼€ç›˜5åˆ†é’Ÿå†…ï¼‰
            logger.debug("  - è§£æäº¤æ˜“è¡Œä¸ºï¼Œå¯»æ‰¾ç‹™å‡»æ‰‹...")
            early_buyers = set()
            suspicious_txs = []

            # å¹¶å‘è·å–äº¤æ˜“è¯¦æƒ…
            tasks = [self._get_parsed_tx(s["signature"]) for s in sigs[:100]]
            txs = await asyncio.gather(*tasks)

            for tx in txs:
                if not tx:
                    continue
                try:
                    meta = tx.get("meta", {})
                    bt = tx.get("blockTime", 0)
                    if bt == 0:
                        continue

                    # è°ä¹°å…¥äº†ï¼Ÿ(PostBalance > PreBalance)
                    # Solana RPC è¿”å›æ ¼å¼ï¼špostTokenBalances å’Œ preTokenBalances
                    post_balances = meta.get("postTokenBalances", [])
                    pre_balances = meta.get("preTokenBalances", [])

                    # åˆ›å»ºä½™é¢æ˜ å°„ï¼ˆå…¼å®¹ä¸åŒçš„æ•°æ®æ ¼å¼ï¼‰
                    pre_balance_map = {}
                    for b in pre_balances:
                        if b.get("mint") == mint_address:
                            owner = b.get("owner")
                            if owner:
                                # å…¼å®¹ä¸åŒçš„é‡‘é¢å­—æ®µå
                                token_amount = b.get("uiTokenAmount", {}) or b.get("tokenAmount", {})
                                amount = token_amount.get("uiAmount") or token_amount.get("amount", 0)
                                if isinstance(amount, str):
                                    try:
                                        amount = float(amount)
                                    except:
                                        amount = 0
                                pre_balance_map[owner] = float(amount)

                    post_balance_map = {}
                    for b in post_balances:
                        if b.get("mint") == mint_address:
                            owner = b.get("owner")
                            if owner:
                                token_amount = b.get("uiTokenAmount", {}) or b.get("tokenAmount", {})
                                amount = token_amount.get("uiAmount") or token_amount.get("amount", 0)
                                if isinstance(amount, str):
                                    try:
                                        amount = float(amount)
                                    except:
                                        amount = 0
                                post_balance_map[owner] = float(amount)

                    # æ‰¾å‡ºä½™é¢å¢åŠ çš„åœ°å€ï¼ˆä¹°å…¥è€…ï¼‰
                    for owner, post_amt in post_balance_map.items():
                        if owner in WHITELIST:
                            continue
                        pre_amt = pre_balance_map.get(owner, 0)
                        if post_amt > pre_amt:
                            # è®°å½•å¼€ç›˜5åˆ†é’Ÿå†…çš„ä¹°å…¥è€…
                            time_diff = bt - launch_time
                            if 0 <= time_diff < 300:  # 5åˆ†é’Ÿ = 300ç§’
                                early_buyers.add(owner)
                                suspicious_txs.append({"owner": owner, "time": bt, "slot": tx.get("slot", 0)})
                                logger.debug(f"  ğŸ¯ Early buyer: {owner[:8]}... at {time_diff}s after launch")
                except Exception as e:
                    logger.debug(f"  âš ï¸ Error parsing tx: {e}")
                    continue

            logger.debug(f"  - é”å®šå¼€ç›˜ç‹™å‡»åœ°å€æ•°: {len(early_buyers)}")

            # 4. èµ„é‡‘åŒæºåˆ†æï¼ˆæœ€è€—æ—¶ä½†æœ€å‡†ï¼‰
            # ä¸ºäº†é€Ÿåº¦ï¼Œåªå–å‰20ä¸ªç–‘ä¼¼åœ°å€è¿›è¡Œæº¯æº
            logger.debug("  - ğŸ•µï¸â€â™‚ï¸ æ‰§è¡Œèµ„é‡‘åŒæºè¿½è¸ª (Funding Source Trace)...")
            sample_suspects = list(early_buyers)[:20]
            if not sample_suspects:
                logger.debug("  âš ï¸ No early buyers found")
                return 0.0, 0.0

            funding_map = await self._analyze_funding_source(sample_suspects)

            # 5. è·å–å½“å‰æŒä»“å¤§æˆ·ï¼ˆéªŒè¯ä»–ä»¬æ˜¯å¦è¿˜æ²¡è·‘ï¼‰
            logger.debug("  - æ£€æŸ¥å½“å‰æŒä»“åˆ†å¸ƒ...")
            top_accs = await self._get_largest_accounts(mint_address, limit=20)

            # è§£æ Top Accounts çš„ Owner
            top_owners = {}  # owner -> amount
            owner_tasks = [self._get_account_owner(acc["address"]) for acc in top_accs]
            owners_res = await asyncio.gather(*owner_tasks)

            for i, owner in enumerate(owners_res):
                if owner:
                    # å…¼å®¹ä¸åŒçš„é‡‘é¢å­—æ®µæ ¼å¼
                    acc_data = top_accs[i]
                    amount = acc_data.get("uiAmount") or acc_data.get("amount", 0)
                    if isinstance(amount, str):
                        try:
                            amount = float(amount)
                        except:
                            amount = 0
                    amt = float(amount)
                    if amt > 0:
                        top_owners[owner] = top_owners.get(owner, 0) + amt
                        logger.debug(f"  ğŸ“Š Top holder: {owner[:8]}... holding {amt:.2f} tokens")

            # ================= è®¡ç®—æœ€ç»ˆæŒ‡æ ‡ =================

            # ğŸ­ è®¡ç®—è€é¼ ä»“å æ¯” (Rat Ratio)
            # å®šä¹‰ï¼šå¼€ç›˜5åˆ†é’Ÿä¹°å…¥ï¼Œä¸”ç›®å‰åœ¨å‰20æŒä»“ä¸­çš„äºº
            rat_holding_amount = 0.0
            confirmed_rats = []

            for owner, amt in top_owners.items():
                if owner in early_buyers:
                    rat_holding_amount += amt
                    confirmed_rats.append(owner)
                    logger.debug(f"  ğŸ­ Rat trader: {owner[:8]}... holding {amt:.2f} tokens")

            rat_ratio = (rat_holding_amount / total_supply) if total_supply > 0 else 0.0

            # ğŸ”— è®¡ç®—æ†ç»‘å æ¯” (Bundle Ratio)
            # å®šä¹‰ï¼šèµ„é‡‘æ¥æºç›¸åŒçš„åœ°å€ç°‡ï¼ŒæŒæœ‰çš„ä»£å¸æ€»é‡
            # æ”¹è¿›ï¼šä¸ä»…ç»Ÿè®¡è¢«èµ„åŠ©åœ°å€ï¼Œè¿˜è¦ç»Ÿè®¡èµ„é‡‘æºæœ¬èº«ï¼ˆå¦‚æœä¹Ÿåœ¨æŒä»“ä¸­ï¼‰
            bundle_holding_amount = 0.0
            bundle_clusters = 0
            bundled_addresses = set()  # å·²ç»Ÿè®¡çš„åœ°å€ï¼Œé¿å…é‡å¤

            # æ‰“å°åŒæºé›†ç¾¤
            logger.debug("  ğŸ” å‘ç°èµ„é‡‘åŒæºé›†ç¾¤:")
            for funder, kids in funding_map.items():
                if len(kids) > 1:  # è‡³å°‘2ä¸ªé’±åŒ…æ¥è‡ªåŒä¸€èµ„é‡‘æº
                    logger.debug(f"    - èµ„é‡‘æº {funder[:8]}... èµ„åŠ©äº† {len(kids)} ä¸ªé’±åŒ…")
                    bundle_clusters += 1
                    
                    # æ£€æŸ¥æ˜¯å¦æœ‰è¢«èµ„åŠ©çš„åœ°å€åœ¨æŒä»“ä¸­
                    has_holder = any(kid in top_owners for kid in kids)
                    # æˆ–è€…èµ„é‡‘æºæœ¬èº«åœ¨æŒä»“ä¸­
                    funder_holding = top_owners.get(funder, 0)
                    
                    if has_holder or funder_holding > 0:
                        # ç»Ÿè®¡æ‰€æœ‰è¢«èµ„åŠ©åœ°å€çš„æŒä»“ï¼ˆåªè¦æœ‰ä¸€ä¸ªåœ¨æŒä»“ä¸­ï¼Œå°±ç»Ÿè®¡å…¨éƒ¨ï¼‰
                        cluster_amount = 0.0
                        for kid in kids:
                            if kid not in bundled_addresses and kid in top_owners:
                                amt = top_owners[kid]
                                cluster_amount += amt
                                bundled_addresses.add(kid)
                                logger.debug(f"      ğŸ“¦ {kid[:8]}... holding {amt:.2f} tokens")
                        
                        # å¦‚æœèµ„é‡‘æºä¹Ÿåœ¨æŒä»“ä¸­ï¼Œä¹Ÿç»Ÿè®¡è¿›å»
                        if funder not in bundled_addresses and funder_holding > 0:
                            cluster_amount += funder_holding
                            bundled_addresses.add(funder)
                            logger.debug(f"      ğŸ“¦ èµ„é‡‘æº {funder[:8]}... holding {funder_holding:.2f} tokens")
                        
                        bundle_holding_amount += cluster_amount
                        logger.debug(f"      âœ… é›†ç¾¤æ€»æŒä»“: {cluster_amount:.2f} tokens ({cluster_amount/total_supply*100:.2f}%)")

            bundle_ratio = (bundle_holding_amount / total_supply) if total_supply > 0 else 0.0
            
            # å¦‚æœèµ„é‡‘åŒæºåˆ†ææ²¡æœ‰æ‰¾åˆ°ç»“æœï¼Œå›é€€åˆ°æ—¶é—´èšç±»æ³•ï¼ˆä½œä¸ºå¤‡é€‰æ–¹æ¡ˆï¼‰
            if bundle_ratio == 0.0 and bundle_clusters == 0 and len(early_buyers) > 0:
                logger.debug("  âš ï¸ èµ„é‡‘åŒæºåˆ†ææœªæ‰¾åˆ°ç»“æœï¼Œä½¿ç”¨æ—¶é—´èšç±»æ³•ä½œä¸ºå¤‡é€‰...")
                # ä½¿ç”¨æ—¶é—´èšç±»ï¼šå¼€ç›˜30ç§’å†…ä¹°å…¥çš„åœ°å€è§†ä¸ºæ†ç»‘
                time_clusters = defaultdict(list)
                for tx_info in suspicious_txs:
                    owner = tx_info["owner"]
                    tx_time = tx_info["time"]
                    if owner in top_owners:
                        # å°†æ—¶é—´ç›¸è¿‘çš„äº¤æ˜“åˆ†ç»„ï¼ˆ30ç§’çª—å£ï¼‰
                        found_cluster = False
                        for cluster_time in list(time_clusters.keys()):
                            if abs(cluster_time - tx_time) <= 30:
                                time_clusters[cluster_time].append(owner)
                                found_cluster = True
                                break
                        if not found_cluster:
                            time_clusters[tx_time] = [owner]
                
                # ç»Ÿè®¡æ—¶é—´ç°‡çš„æŒä»“
                for cluster_time, owners in time_clusters.items():
                    if len(owners) >= 2:  # è‡³å°‘2ä¸ªåœ°å€åœ¨åŒä¸€æ—¶é—´çª—å£
                        cluster_amount = sum(top_owners.get(owner, 0) for owner in owners)
                        if cluster_amount > 0:
                            bundle_holding_amount += cluster_amount
                            logger.debug(f"  â° æ—¶é—´ç°‡ ({len(owners)} addresses): {cluster_amount:.2f} tokens")
                
                bundle_ratio = (bundle_holding_amount / total_supply) if total_supply > 0 else 0.0
                if bundle_ratio > 0:
                    logger.debug(f"  âœ… æ—¶é—´èšç±»æ³•æ‰¾åˆ°æ†ç»‘å æ¯”: {bundle_ratio*100:.2f}%")

            # è½¬æ¢ä¸ºå°æ•°å½¢å¼ï¼ˆ0.23 = 23%ï¼‰
            logger.info(f"âœ… Analysis complete: bundled={bundle_ratio:.4f} ({bundle_ratio*100:.2f}%), rat={rat_ratio:.4f} ({rat_ratio*100:.2f}%)")
            logger.debug(f"  Bundled clusters: {bundle_clusters}, confirmed rats: {len(confirmed_rats)}")

            return bundle_ratio, rat_ratio

        except Exception as e:
            logger.warning(f"âŒ Solana analysis failed: {e}")
            import traceback
            logger.debug(f"Traceback: {traceback.format_exc()}")
            return None, None


async def calculate_rat_and_bundled(
    mint_address: str,
    sol_config: Optional[ChainConfig],
    client
) -> Tuple[Optional[float], Optional[float]]:
    """
    ä¾¿æ·å‡½æ•°ï¼šè®¡ç®—è€é¼ ä»“å’Œæ†ç»‘å æ¯”
    è¿”å› (rat_ratio, bundled_ratio)ï¼Œå€¼ä¸ºå°æ•°å½¢å¼ï¼ˆ0.23 = 23%ï¼‰
    """
    if not sol_config or not sol_config.rpc_url:
        return None, None

    analyzer = SolanaRoughAnalyzer(sol_config.rpc_url, client)
    bundled, rat = await analyzer.analyze(mint_address)
    return rat, bundled

--- File: ./src/__init__.py ---
# Package initializer


--- File: ./src/chart.py ---
from __future__ import annotations

from datetime import datetime, timedelta, timezone
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, List, Optional
import math
import random

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.ticker as ticker
import mplfinance as mpf
import pandas as pd

from .models import TokenMetrics


def render_chart(
    metrics: TokenMetrics,
    bars: List[Dict[str, Any]],
    outfile: Optional[str | Path] = None,
) -> Optional[BytesIO]:
    """
    ç»˜åˆ¶æ ‡å‡†çš„Kçº¿å›¾ï¼ˆç±»ä¼¼TradingViewé£æ ¼ï¼‰
    """
    import logging
    logger = logging.getLogger("ca_filter_bot.chart")
    
    # 1. æ•°æ®è½¬æ¢
    if not bars:
        error_msg = "No chart data provided - API failed to return data"
        logger.error(f"âŒ {error_msg}")
        raise ValueError(error_msg)
    
    df = _bars_to_df(bars)
    
    if df is None or df.empty:
        error_msg = "Chart data conversion failed - invalid data format"
        logger.error(f"âŒ {error_msg}")
        raise ValueError(error_msg)
    
    # å›ºå®šæ˜¾ç¤º1å°æ—¶çª—å£ï¼ˆ60æ ¹Kçº¿ï¼‰
    # - å¦‚æœè¶…è¿‡ 60 æ ¹ï¼Œåªä¿ç•™æœ€è¿‘ 60 æ ¹
    # - å¦‚æœå°‘äº 60 æ ¹ï¼Œè¡¥é½æ—¶é—´èŒƒå›´åˆ°1å°æ—¶ï¼Œä½†è¡¥é½çš„éƒ¨åˆ†ä¸æ˜¾ç¤ºKçº¿ï¼ˆæ˜¾ç¤ºç©ºç™½ï¼‰
    TARGET_BARS = 60
    if len(df) >= TARGET_BARS:
        df = df.iloc[-TARGET_BARS:]
    else:
        # å¦‚æœå°‘äº60æ ¹ï¼Œéœ€è¦è¡¥é½æ—¶é—´èŒƒå›´åˆ°1å°æ—¶
        # è®¡ç®—æœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´
        last_time = df.index[-1]
        # è®¡ç®—1å°æ—¶å‰çš„æ—¶é—´
        one_hour_before = last_time - pd.Timedelta(hours=1)
        # åˆ›å»ºå®Œæ•´1å°æ—¶çš„æ—¶é—´ç´¢å¼•ï¼ˆæ¯åˆ†é’Ÿä¸€ä¸ªï¼‰
        full_hour_index = pd.date_range(start=one_hour_before, end=last_time, freq='1min')
        # é‡æ–°ç´¢å¼•ï¼Œè¡¥é½ç¼ºå¤±çš„æ—¶é—´ç‚¹ï¼ˆç¼ºå¤±çš„ç”¨NaNå¡«å……ï¼‰
        df = df.reindex(full_hour_index)
        # è¡¥é½çš„éƒ¨åˆ†ä¼šè‡ªåŠ¨æ˜¯NaNï¼Œä¸ä¼šæ˜¾ç¤ºKçº¿ï¼Œä½†ä¿æŒæ—¶é—´èŒƒå›´æ˜¯å®Œæ•´çš„1å°æ—¶
    
    # 2. è®¡ç®—å…³é”®æ•°æ®
    latest_close = float(df["Close"].iloc[-1])
    # æ‰¾åˆ°ç¬¬ä¸€æ ¹æœ‰æ•ˆçš„Kçº¿ï¼ˆä¸æ˜¯NaNï¼‰
    first_valid_idx = None
    for idx in range(len(df)):
        if pd.notna(df["Open"].iloc[idx]) and pd.notna(df["Close"].iloc[idx]):
            first_valid_idx = idx
            break
    
    if first_valid_idx is None:
        # å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œä½¿ç”¨é»˜è®¤å€¼
        first_open = latest_close
        change_pct = 0.0
    else:
        first_open = float(df["Open"].iloc[first_valid_idx])
        change_amt = latest_close - first_open
        change_pct = (change_amt / first_open * 100) if first_open != 0 else 0.0
    
    # ç¡®ä¿ change_pct æ˜¯æœ‰æ•ˆæ•°å€¼
    if pd.isna(change_pct) or not isinstance(change_pct, (int, float)):
        change_pct = 0.0
    
    # 3. é¢œè‰²å®šä¹‰ï¼ˆæ¶¨ç»¿è·Œçº¢ï¼‰
    COLOR_UP = "#089981"    # æ¶¨ï¼šç»¿è‰²
    COLOR_DOWN = "#F23645"  # è·Œï¼šçº¢è‰²
    COLOR_BG = "#0D1117"    # èƒŒæ™¯ï¼šæ·±è‰²
    GRID_COLOR = "#2A2F35"  # æ·±ç°ç½‘æ ¼
    
    is_up = change_pct >= 0
    main_color = COLOR_UP if is_up else COLOR_DOWN
    
    # 4. åˆ›å»ºå¸‚åœºé¢œè‰²é…ç½®
    # å…³é”®ï¼šç¡®ä¿Kçº¿å®ä½“æœ‰é¢œè‰²ï¼Œä¸æ˜¯ç©ºå¿ƒ
    # ä½¿ç”¨ 'filled' æ¨¡å¼ç¡®ä¿å®ä½“å¡«å……
    mc = mpf.make_marketcolors(
        up=COLOR_UP,      # æ¶¨ï¼šç»¿è‰²å®ä½“
        down=COLOR_DOWN,  # è·Œï¼šçº¢è‰²å®ä½“
        edge={'up': COLOR_UP, 'down': COLOR_DOWN},  # è¾¹æ¡†é¢œè‰²ï¼ˆä¸å®ä½“åŒè‰²ï¼‰
        wick={'up': COLOR_UP, 'down': COLOR_DOWN},  # å½±çº¿é¢œè‰²
        volume={'up': COLOR_UP + "80", 'down': COLOR_DOWN + "80"},  # æˆäº¤é‡ï¼ˆå¸¦é€æ˜åº¦ï¼‰
        ohlc='i',  # ç»§æ‰¿æ¶¨è·Œè‰²
        alpha=1.0,  # å®Œå…¨ä¸é€æ˜ï¼Œç¡®ä¿å®ä½“å¯è§
        inherit=True  # ç»§æ‰¿åŸºç¡€æ ·å¼
    )
    
    # 5. åˆ›å»ºæ ·å¼
    style = mpf.make_mpf_style(
        base_mpf_style='nightclouds',
        marketcolors=mc,
        gridstyle=':',
        gridcolor=GRID_COLOR,
        facecolor=COLOR_BG,
        figcolor=COLOR_BG,
        rc={
            'font.family': 'DejaVu Sans',
            'font.size': 9,
            'axes.labelsize': 8,
            'axes.linewidth': 0.5,
            'axes.edgecolor': '#4B5563',
            'axes.labelcolor': '#E5E7EB',
            'xtick.color': '#E5E7EB',
            'ytick.color': '#E5E7EB',
        }
    )
    
    # 6. ç¡®ä¿æ•°æ®åˆ—åæ­£ç¡®ï¼ˆmplfinanceè¦æ±‚é¦–å­—æ¯å¤§å†™ï¼‰
    # ç¡®ä¿åˆ—é¡ºåºæ­£ç¡®ï¼šOpen, High, Low, Close
    df_plot = df[['Open', 'High', 'Low', 'Close']].copy()
    
    # 7. ç»˜åˆ¶Kçº¿å›¾ï¼ˆä¸æ˜¾ç¤ºæˆäº¤é‡ï¼‰
    try:
        fig, axlist = mpf.plot(
            df_plot,
            type='candle',  # æ ‡å‡†Kçº¿å›¾
            volume=False,  # ä¸æ˜¾ç¤ºæˆäº¤é‡
            style=style,
            figsize=(10, 6),
            datetime_format='%H:%M',
            xrotation=0,
            ylabel='',
            scale_width_adjustment=dict(candle=1),  # å‡å°å®½åº¦ï¼Œé¿å…é‡å 
            tight_layout=True,
            returnfig=True,
            show_nontrading=False,
            warn_too_much_data=10000,
            update_width_config=dict(
                candle_linewidth=1,  # é€‚ä¸­çº¿å®½
                candle_width=0.9,  # å‡å° K çº¿å®½åº¦ï¼Œé¿å…é‡å 
            )
        )
    except Exception as e:
        logger.error(f"âŒ mplfinance plot failed: {e}", exc_info=True)
        raise
    
    ax_main = axlist[0]  # Kçº¿å›¾ä¸»å›¾
    
    # 8. Yè½´ä»·æ ¼æ ¼å¼åŒ–ï¼ˆå¤„ç†å°æ•°å€¼ï¼‰
    if latest_close > 0:
        # è®¡ç®—éœ€è¦çš„å°æ•°ä½æ•°
        decimals = max(0, -int(math.floor(math.log10(latest_close))) + 4)
    else:
        decimals = 8
    
    formatter_str = f"{{:.{decimals}f}}"
    
    def price_fmt(x, p):
        return formatter_str.format(x).rstrip('0').rstrip('.')
    
    ax_main.yaxis.set_major_formatter(ticker.FuncFormatter(price_fmt))
    ax_main.yaxis.tick_right()  # ä»·æ ¼åœ¨å³ä¾§
    
    # 8.5. å›ºå®šXè½´ä¸º1å°æ—¶èŒƒå›´ï¼ˆå³ä½¿æ•°æ®å°‘äº60æ ¹ï¼‰
    # mplfinance ä½¿ç”¨æ•´æ•°ç´¢å¼•ï¼ˆ0, 1, 2...ï¼‰ï¼Œæ‰€ä»¥å›ºå®šæ˜¾ç¤º60ä¸ªä½ç½®
    # ç¡®ä¿Xè½´å§‹ç»ˆæ˜¾ç¤º60ä¸ªä½ç½®ï¼ˆ0-59ï¼‰ï¼Œå¯¹åº”1å°æ—¶
    ax_main.set_xlim([-0.5, 59.5])
    
    # 9. å·¦ä¸Šè§’ä¿¡æ¯æ¡†ï¼ˆå°å°ºå¯¸ï¼Œé¿å…è¢«èœ¡çƒ›å›¾é®æŒ¡ï¼‰
    # ä½¿ç”¨åŠé€æ˜èƒŒæ™¯æ¡†ï¼Œç¡®ä¿æ–‡å­—æ¸…æ™°å¯è§
    price_display = formatter_str.format(latest_close)
    sign = "+" if change_pct > 0 else ""
    change_str = f"{sign}{change_pct:.2f}%"
    
    # åˆ›å»ºä¿¡æ¯æ¡†æ–‡æœ¬ï¼ˆç´§å‡‘æ ¼å¼ï¼Œä¸‰è¡Œï¼‰
    info_lines = [
        f"{metrics.symbol} / USD",
        f"${price_display}  {change_str} (1H)",
    ]
    info_text = "\n".join(info_lines)
    
    # ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯æ¡†ï¼ˆç™½è‰²èƒŒæ™¯ï¼Œå¸¦è¾¹æ¡†ï¼Œå°å°ºå¯¸ï¼‰
    props = dict(
        boxstyle='round,pad=0.3',
        facecolor=COLOR_BG,
        alpha=0.88,
        edgecolor=main_color,
        linewidth=1.2,
    )
    
    # åœ¨å·¦ä¸Šè§’æ˜¾ç¤ºï¼ˆx=0.02è¡¨ç¤ºå·¦å¯¹é½ï¼Œy=0.98è¡¨ç¤ºé¡¶éƒ¨ï¼‰
    # å°å­—ä½“ï¼Œç´§å‡‘å¸ƒå±€
    ax_main.text(
        0.02, 0.98,
        info_text,
        transform=ax_main.transAxes,
        fontsize=9,  # å°å­—ä½“
        fontweight='bold',
        color='#E5E7EB',
        bbox=props,
        verticalalignment='top',
        horizontalalignment='left',  # å·¦å¯¹é½
        family='monospace',  # ç­‰å®½å­—ä½“ï¼Œä»·æ ¼å¯¹é½æ›´æ•´é½
        zorder=10  # ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œä¸è¢«Kçº¿é®æŒ¡
    )
    
    # 10. æ¸…ç†æ ‡é¢˜
    ax_main.set_title("")
    
    # 11. ä¿å­˜åˆ°å†…å­˜ï¼ˆBytesIOï¼‰è€Œä¸æ˜¯æ–‡ä»¶
    buffer = BytesIO()
    fig.savefig(buffer, format='png', dpi=120, bbox_inches='tight', pad_inches=0.05, facecolor=COLOR_BG)
    buffer.seek(0)  # é‡ç½®æŒ‡é’ˆåˆ°å¼€å¤´
    plt.close(fig)
    
    return buffer


def _bars_to_df(bars: List[Dict[str, Any]]) -> pd.DataFrame:
    """
    å°†åŸå§‹Kçº¿æ•°æ®è½¬æ¢ä¸ºDataFrame
    æ”¯æŒ Birdeye API æ ¼å¼: {t (unixTime), o, h, l, c, v}
    å…³é”®ï¼šBirdeyeè¿”å›çš„æ•°æ®å·²ç»æ˜¯1åˆ†é’ŸKçº¿ï¼Œä¸éœ€è¦é‡é‡‡æ ·
    """
    import logging
    logger = logging.getLogger("ca_filter_bot.chart")
    
    if not bars:
        logger.warning("âš ï¸ No bars data provided")
        return pd.DataFrame()
    
    logger.debug(f"ğŸ“Š Converting {len(bars)} bars to DataFrame")
    
    # å…ˆæ£€æŸ¥åŸå§‹æ•°æ®æ ¼å¼
    if bars:
        sample_bar = bars[0]
        logger.debug(f"ğŸ“Š Sample raw bar keys: {list(sample_bar.keys())}")
        logger.debug(f"ğŸ“Š Sample raw bar: {sample_bar}")
    
    df = pd.DataFrame(bars)
    
    # å­—æ®µæ˜ å°„
    rename_map = {
        "t": "Date", "time": "Date",
        "o": "Open", "open": "Open",
        "h": "High", "high": "High",
        "l": "Low", "low": "Low",
        "c": "Close", "close": "Close",
        "v": "Volume", "volume": "Volume",
    }
    df = df.rename(columns=rename_map)
    
    # æ£€æŸ¥å¿…éœ€å­—æ®µ
    required = ["Date", "Open", "High", "Low", "Close"]
    if not all(col in df.columns for col in required):
        logger.error(f"âŒ Missing required columns. Available: {list(df.columns)}")
        return pd.DataFrame()
    
    # è½¬æ¢æ—¶é—´æˆ³ï¼ˆBirdeyeè¿”å›çš„æ˜¯ç§’çº§æ—¶é—´æˆ³ unixTimeï¼‰
    df["Date"] = pd.to_numeric(df["Date"], errors='coerce')
    # åˆ¤æ–­æ˜¯ç§’è¿˜æ˜¯æ¯«ç§’ï¼šå¦‚æœå¤§äº1e11å°±æ˜¯æ¯«ç§’ï¼Œå¦åˆ™æ˜¯ç§’
    if len(df) > 0:
        first_ts = df["Date"].iloc[0]
        if first_ts > 1e11:
            unit = 'ms'
        else:
            unit = 's'
        logger.debug(f"ğŸ“Š Time unit: {unit}, first timestamp: {first_ts}")
    else:
        unit = 's'
    
    df["Date"] = pd.to_datetime(df["Date"], unit=unit, errors='coerce')
    
    # è½¬æ¢ä¸ºä¸­å›½æ—¶é—´ï¼ˆUTC+8ï¼‰
    if df["Date"].notna().any():
        # å°†æ—¶é—´æˆ³è½¬æ¢ä¸ºUTCæ—¶åŒºï¼Œç„¶åè½¬æ¢ä¸ºä¸­å›½æ—¶é—´ï¼ˆUTC+8ï¼‰
        # å¦‚æœæ—¶é—´å·²ç»æ˜¯æ—¶åŒºæ„ŸçŸ¥çš„ï¼Œç›´æ¥è½¬æ¢ï¼›å¦åˆ™å…ˆ localize åˆ° UTC
        if df["Date"].dt.tz is None:
            df["Date"] = df["Date"].dt.tz_localize('UTC')
        df["Date"] = df["Date"].dt.tz_convert('Asia/Shanghai')
    
    # è®¾ç½®ç´¢å¼•
    df = df.set_index("Date")
    df.index = pd.DatetimeIndex(df.index)
    
    # ç¡®ä¿æ•°å€¼ç±»å‹ï¼ˆå…³é”®ï¼šä¿æŒåŸå§‹çš„å¼€ç›˜ä»·å’Œæ”¶ç›˜ä»·ï¼‰
    cols = ["Open", "High", "Low", "Close"]
    df[cols] = df[cols].apply(pd.to_numeric, errors='coerce')
    
    # ç§»é™¤æ— æ•ˆæ•°æ®
    before_drop = len(df)
    df = df.dropna(subset=cols)
    after_drop = len(df)
    if before_drop != after_drop:
        logger.warning(f"âš ï¸ Dropped {before_drop - after_drop} rows with NaN values")
    
    # æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§
    if len(df) > 0:
        # æ£€æŸ¥æ˜¯å¦æœ‰å®ä½“ï¼ˆOpen != Closeï¼‰
        body_count = (df['Open'] != df['Close']).sum()
        logger.debug(f"ğŸ“Š Bars with body (Open != Close): {body_count}/{len(df)}")
        
        # æ£€æŸ¥æ•°æ®èŒƒå›´
        logger.debug(f"ğŸ“Š Price range: O[{df['Open'].min():.8f}, {df['Open'].max():.8f}], "
                    f"C[{df['Close'].min():.8f}, {df['Close'].max():.8f}]")
    
    # é‡è¦ï¼šBirdeyeè¿”å›çš„æ•°æ®å·²ç»æ˜¯1åˆ†é’ŸKçº¿ï¼Œä¸éœ€è¦é‡é‡‡æ ·
    # é‡é‡‡æ ·ä¼šç ´ååŸå§‹çš„å¼€ç›˜ä»·å’Œæ”¶ç›˜ä»·
    # åªéœ€è¦ç¡®ä¿æ•°æ®æŒ‰æ—¶é—´æ’åº
    df = df.sort_index()
    
    return df


def _generate_fallback_chart(metrics: TokenMetrics) -> pd.DataFrame:
    """
    ç”Ÿæˆæ¨¡æ‹ŸKçº¿æ•°æ®ï¼ˆå½“æ²¡æœ‰çœŸå®æ•°æ®æ—¶ï¼‰
    å…³é”®ï¼šç¡®ä¿Openå’ŒCloseä¸åŒï¼Œæ‰èƒ½æ˜¾ç¤ºKçº¿å®ä½“
    """
    import logging
    logger = logging.getLogger("ca_filter_bot.chart")
    
    current_price = metrics.price_usd or 0.0001
    if current_price == 0:
        current_price = 0.0001
    
    logger.warning(f"âš ï¸ Using fallback chart data for price: {current_price}")
    
    # ç”Ÿæˆæœ€è¿‘60åˆ†é’Ÿçš„æ•°æ®ï¼ˆä½¿ç”¨ä¸­å›½æ—¶é—´ï¼‰
    tz_cn = timezone(timedelta(hours=8))
    now = datetime.now(tz_cn)
    timestamps = [now - timedelta(minutes=i) for i in range(59, -1, -1)]
    
    # æ·»åŠ éšæœºæ³¢åŠ¨ï¼Œç¡®ä¿æ¯æ ¹Kçº¿éƒ½æœ‰å®ä½“ï¼ˆOpen != Closeï¼‰
    # ä½¿ç”¨å›ºå®šseedï¼ˆåŸºäºä»·æ ¼ï¼‰ï¼Œç¡®ä¿åŒä¸€ä»·æ ¼ç”Ÿæˆçš„å›¾è¡¨ä¸€è‡´
    # å°†ä»·æ ¼è½¬æ¢ä¸ºæ•´æ•°ä½œä¸ºseedï¼Œç¡®ä¿ç›¸åŒä»·æ ¼ç”Ÿæˆç›¸åŒå›¾è¡¨
    price_int = int(current_price * 1000000000)  # è½¬æ¢ä¸ºæ•´æ•°ï¼ˆä¿ç•™9ä½å°æ•°ç²¾åº¦ï¼‰
    random.seed(price_int % 1000000)  # ä½¿ç”¨ä»·æ ¼ä½œä¸ºseedï¼Œç¡®ä¿åŒä¸€ä»·æ ¼ç”Ÿæˆç›¸åŒå›¾è¡¨
    data = []
    base_price = current_price
    
    for i, ts in enumerate(timestamps):
        # æ¯æ ¹Kçº¿éƒ½æœ‰ä¸åŒçš„å¼€ç›˜ä»·å’Œæ”¶ç›˜ä»·
        # ä½¿ç”¨è¶‹åŠ¿ + éšæœºæ³¢åŠ¨
        trend = (i / len(timestamps) - 0.5) * 0.02  # è½»å¾®è¶‹åŠ¿
        random_change = random.uniform(-0.01, 0.01)  # éšæœºæ³¢åŠ¨
        
        # å¼€ç›˜ä»·ï¼šåŸºäºåŸºç¡€ä»·æ ¼ + è¶‹åŠ¿
        open_price = base_price * (1 + trend + random_change)
        
        # æ”¶ç›˜ä»·ï¼šå¼€ç›˜ä»· + éšæœºå˜åŒ–ï¼ˆç¡®ä¿ä¸åŒï¼‰
        close_change = random.uniform(-0.005, 0.005)
        close_price = open_price * (1 + close_change)
        
        # ç¡®ä¿æ”¶ç›˜ä»·å’Œå¼€ç›˜ä»·ä¸åŒï¼ˆè‡³å°‘0.1%çš„å·®å¼‚ï¼‰
        if abs(close_price - open_price) / open_price < 0.001:
            close_price = open_price * (1 + (0.001 if random.random() > 0.5 else -0.001))
        
        # æœ€é«˜ä»·å’Œæœ€ä½ä»·
        high_price = max(open_price, close_price) * (1 + random.uniform(0, 0.003))
        low_price = min(open_price, close_price) * (1 - random.uniform(0, 0.003))
        
        data.append({
            "Date": ts,
            "Open": open_price,
            "High": high_price,
            "Low": low_price,
            "Close": close_price,
            "Volume": random.randint(500, 1500),
        })
        
        # æ›´æ–°åŸºç¡€ä»·æ ¼ï¼ˆæ¨¡æ‹Ÿä»·æ ¼èµ°åŠ¿ï¼‰
        base_price = close_price
    
    df = pd.DataFrame(data)
    df = df.set_index("Date")
    df.index = pd.DatetimeIndex(df.index)
    
    # éªŒè¯æ•°æ®
    body_count = (df['Open'] != df['Close']).sum()
    logger.debug(f"ğŸ“Š Fallback chart: {body_count}/{len(df)} bars have body (Open != Close)")
    
    return df

--- File: ./src/bot.py ---
from __future__ import annotations

import asyncio
import html
import logging
import os
import time
import re
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Awaitable, Callable, List, Optional, Tuple, Dict, Any

from telegram import Update, BotCommand, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters,
)
from telethon import events

from .state import StateStore

logger = logging.getLogger("ca_filter_bot.bot")

# ä¸­å›½æ—¶åŒºï¼ˆUTC+8ï¼‰
TZ_SHANGHAI = timezone(timedelta(hours=8))


CA_PATTERN = re.compile(r"[1-9A-HJ-NP-Za-km-z]{32,44}|0x[a-fA-F0-9]{40}")


class BotApp:
    def __init__(
        self,
        admin_ids: List[int],
        state: StateStore,
        process_ca: Optional[Callable[[str, str, bool], Awaitable[Tuple[Optional[str], Optional[str], Optional[str]]]]],
        scheduler=None,
    ):
        self.admin_ids = admin_ids
        self.state = state
        self.process_ca = process_ca
        self.scheduler = scheduler
        tg_token = os.getenv("TG_BOT_TOKEN")
        if not tg_token:
            raise RuntimeError("TG_BOT_TOKEN environment variable is required")
        self.app: Application = (
            ApplicationBuilder()
            .token(tg_token)
            .concurrent_updates(True)
            .build()
        )
        self.app.add_handler(CommandHandler("start", self.cmd_start))
        self.app.add_handler(CommandHandler("menu", self.cmd_menu))
        self.app.add_handler(CommandHandler("help", self.cmd_menu))
        self.app.add_handler(CommandHandler("c", self.cmd_c))
        self.app.add_handler(CommandHandler("settings", self.cmd_settings))
        self.app.add_handler(CommandHandler("tasks", self.cmd_tasks))
        self.app.add_handler(CommandHandler("task_pause", self.cmd_task_pause))
        self.app.add_handler(CommandHandler("task_resume", self.cmd_task_resume))
        self.app.add_handler(CommandHandler("add_client", self.cmd_add_client))
        self.app.add_handler(CommandHandler("add_task", self.cmd_add_task))
        # å†…è”æŒ‰é’®å›è°ƒå¤„ç†
        self.app.add_handler(CallbackQueryHandler(self.handle_callback))
        # ç›‘å¬æ–‡æœ¬æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æŒ‰é’®ç‚¹å‡»åçš„æ–‡æœ¬è¾“å…¥ï¼‰
        msg_filter = filters.TEXT & (~filters.COMMAND)
        self.app.add_handler(MessageHandler(msg_filter, self.on_text))
        # ç›‘å¬æ–‡æ¡£ï¼ˆç”¨äºæ¥æ”¶ .session æ–‡ä»¶ç­‰ï¼‰
        doc_filter = filters.Document.ALL
        self.app.add_handler(MessageHandler(doc_filter, self.on_document))

    async def cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id if update.effective_user else None
        is_admin = user_id in self.admin_ids
        
        text = (
            "ğŸ¤– **CAè¿‡æ»¤æœºå™¨äººå·²å¯åŠ¨**\n\n"
            "ğŸ” ä½¿ç”¨ `/c <åˆçº¦åœ°å€>` æ‰‹åŠ¨æŸ¥è¯¢CA\n\n"
            "ğŸ’¡ **æç¤º**ï¼šæœºå™¨äººä¼šè‡ªåŠ¨ç›‘å¬å·²é…ç½®çš„ç¾¤ç»„ï¼Œæå–åˆçº¦åœ°å€å¹¶è¿‡æ»¤æ¨é€ã€‚"
        )
        
        if is_admin:
            # ç»™ç®¡ç†å‘˜æ˜¾ç¤ºé”®ç›˜èœå•
            keyboard = [
                [KeyboardButton("ğŸ“Š æŸ¥çœ‹é…ç½®"), KeyboardButton("ğŸ” ç­›é€‰æ¡ä»¶")],
                [KeyboardButton("ğŸ‘¥ ç›‘å¬ç¾¤ç»„"), KeyboardButton("ğŸ“¤ æ¨é€ç›®æ ‡")],
                [KeyboardButton("ğŸ“‹ æŸ¥çœ‹ä»»åŠ¡"), KeyboardButton("ğŸ—“ï¸ ä»»åŠ¡ç®¡ç†")],
            ]
            reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            text += "\n\nâœ… **ç®¡ç†å‘˜æƒé™å·²æ¿€æ´»**\nä½¿ç”¨ä¸‹æ–¹æŒ‰é’®è¿›è¡Œé…ç½®"
            await update.message.reply_text(text, parse_mode="Markdown", reply_markup=reply_markup)
        else:
            await update.message.reply_text(text, parse_mode="Markdown")

    async def cmd_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        is_admin = update.effective_user.id in self.admin_ids
        
        text = "ğŸ“‹ **CAè¿‡æ»¤æœºå™¨äºº - å‘½ä»¤èœå•**\n\n"
        
        text += "ğŸ” **æŸ¥è¯¢å‘½ä»¤**\n"
        text += "`/c <åˆçº¦åœ°å€>` - æ‰‹åŠ¨æŸ¥è¯¢CAå¹¶è¿”å›ç»“æœ\n"
        text += "`/settings` - æŸ¥çœ‹å½“å‰æ‰€æœ‰é…ç½®\n\n"
        
        if is_admin:
            text += "ğŸ‘¥ **ç›‘å¬ç¾¤ç»„ç®¡ç†**\n"
            text += "`/add_listen [chat_id]` - æ·»åŠ ç›‘å¬ç¾¤ï¼ˆæ— å‚æ•°åˆ™æ·»åŠ å½“å‰ç¾¤ï¼‰\n"
            text += "`/del_listen <chat_id>` - åˆ é™¤ç›‘å¬ç¾¤\n"
            text += "`/list_listen` - æŸ¥çœ‹æ‰€æœ‰ç›‘å¬ç¾¤\n\n"
            
            text += "ğŸ“¤ **æ¨é€ç›®æ ‡ç®¡ç†**\n"
            text += "`/add_push [chat_id]` - æ·»åŠ æ¨é€ç›®æ ‡ï¼ˆç¾¤/æœºå™¨äºº/ä¸ªäººï¼‰\n"
            text += "`/del_push <chat_id>` - åˆ é™¤æ¨é€ç›®æ ‡\n"
            text += "`/list_push` - æŸ¥çœ‹æ‰€æœ‰æ¨é€ç›®æ ‡\n\n"
            
            text += "âš™ï¸ **ç­›é€‰æ¡ä»¶è®¾ç½®**\n"
            text += "è¯·åœ¨ç§èŠç•Œé¢ä½¿ç”¨æŒ‰é’®ã€ŒğŸ” ç­›é€‰æ¡ä»¶ã€è¿›å…¥å†…è”èœå•è®¾ç½®ç­›é€‰æ¡ä»¶ã€‚\n"
        else:
            text += "âš ï¸ ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨é…ç½®å‘½ä»¤\n"
        
        await update.message.reply_text(text, parse_mode="Markdown")

    async def cmd_c(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id if update.effective_user else None
        logger.info(f"ğŸ“¥ /c command from user {user_id}")
        
        if not context.args:
            await update.message.reply_text(
                "âŒ ç”¨æ³•: `/c <åˆçº¦åœ°å€>`\n\n"
                "ğŸ’¡ æ”¯æŒ Solana å’Œ BSC é“¾çš„åˆçº¦åœ°å€",
                parse_mode="Markdown"
            )
            return
        ca = context.args[0].strip()
        chain = chain_hint(ca)
        logger.info(f"ğŸ” Manual query: {chain} - {ca}")
        await update.message.reply_text(f"â³ æ­£åœ¨å¤„ç† `{ca}` ...", parse_mode="Markdown")
        if not self.process_ca:
            await update.message.reply_text("âŒ å¤„ç†åŠŸèƒ½æœªå°±ç»ª")
            return
        try:
            current_task = await self.state.current_task()
            img_buffer, caption, error_msg = await self.process_ca(chain, ca, True, task_id=current_task)
            if error_msg:
                await update.message.reply_text(
                    f"âŒ <b>æŸ¥è¯¢å¤±è´¥</b>\n\n<code>{ca}</code>\n\n{error_msg}",
                    parse_mode="HTML"
                )
            elif img_buffer and caption:
                # Send photo with caption (img_buffer is BytesIO)
                img_buffer.seek(0)  # ç¡®ä¿æŒ‡é’ˆåœ¨å¼€å¤´
                await update.message.reply_photo(photo=img_buffer, caption=caption, parse_mode="HTML")
            elif caption:
                # Send text only if no photo
                await update.message.reply_text(caption, parse_mode="HTML")
            else:
                await update.message.reply_text(f"âŒ æœªæ‰¾åˆ°æ•°æ®: <code>{ca}</code>", parse_mode="HTML")
        except Exception as e:
            logger.error(f"âŒ Error in cmd_c: {e}", exc_info=True)
            await update.message.reply_text(f"âŒ å¤„ç†å¤±è´¥: {str(e)}")

    async def cmd_settings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        snap = await self.state.snapshot()
        
        tasks = snap.get("tasks", {})
        current = snap.get("current_task")
        if not tasks:
            await update.message.reply_text("âš ï¸ æš‚æ— ä»»åŠ¡é…ç½®ã€‚", parse_mode="HTML")
            return
        
        # è·å– scheduler ä¸­çš„ä»»åŠ¡ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤ºå®šæ—¶æ—¶é—´ï¼‰
        scheduler_tasks = {}
        if self.scheduler:
            for st in self.scheduler.list_tasks():
                scheduler_tasks[st.get("id")] = st
        
        text = f"âš™ï¸ <b>æ‰€æœ‰ä»»åŠ¡é…ç½®</b> ({len(tasks)}ä¸ª)\n\n"
        
        # éå†æ‰€æœ‰ä»»åŠ¡
        for tid, task_cfg in tasks.items():
            is_current = (tid == current)
            current_tag = "ï¼ˆå½“å‰ï¼‰" if is_current else ""
            text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            text += f"ğŸ“‹ <b>{html.escape(tid)}</b> {current_tag}\n\n"
            
            # æ˜¾ç¤ºå®šæ—¶ä¿¡æ¯
            start_time = task_cfg.get("start_time")
            end_time = task_cfg.get("end_time")
            interval_minutes = None
            if tid in scheduler_tasks:
                st = scheduler_tasks[tid]
                interval_minutes = st.get("interval_minutes")
            
            if interval_minutes:
                text += f"â° <b>å®šæ—¶ä»»åŠ¡</b>: æ¯ {interval_minutes} åˆ†é’Ÿ\n"
            if start_time or end_time:
                text += f"ğŸ• <b>æ—¶é—´çª—</b>: {start_time or '--:--'} ~ {end_time or '--:--'}\n"
            if interval_minutes or start_time or end_time:
                text += "\n"
            
            listen_chats = task_cfg.get("listen_chats", [])
            text += f"ğŸ‘¥ <b>ç›‘å¬ç¾¤ç»„</b> ({len(listen_chats)}ä¸ª)\n"
            if listen_chats:
                for chat_id in listen_chats[:5]:  # æœ€å¤šæ˜¾ç¤º5ä¸ª
                    chat_info = await self._get_chat_info(chat_id)
                    chat_name = chat_info.get('title', f'ç¾¤ç»„ {chat_id}') if chat_info else f'ç¾¤ç»„ {chat_id}'
                    chat_name_escaped = html.escape(str(chat_name))
                    chat_id_escaped = html.escape(str(chat_id))
                    text += f"â€¢ <b>{chat_name_escaped}</b> (<code>{chat_id_escaped}</code>)\n"
                if len(listen_chats) > 5:
                    text += f"â€¢ ... è¿˜æœ‰ {len(listen_chats) - 5} ä¸ª\n"
            else:
                text += "â€¢ æš‚æ— \n"
            text += "\n"
            
            push_chats = task_cfg.get("push_chats", [])
            text += f"ğŸ“¤ <b>æ¨é€ç›®æ ‡</b> ({len(push_chats)}ä¸ª)\n"
            if push_chats:
                for chat_id in push_chats[:5]:  # æœ€å¤šæ˜¾ç¤º5ä¸ª
                    chat_info = await self._get_chat_info(chat_id)
                    if chat_info:
                        chat_name = chat_info.get('title', f'ç›®æ ‡ {chat_id}')
                        chat_type = chat_info.get('type', 'unknown')
                        username = chat_info.get('username')
                        chat_id_display = chat_info.get('id', chat_id)
                        
                        type_info = {
                            'group': ('ğŸ‘¥', 'ç¾¤ç»„'),
                            'supergroup': ('ğŸ‘¥', 'ç¾¤ç»„'),
                            'channel': ('ğŸ“¢', 'é¢‘é“'),
                            'private': ('ğŸ‘¤', 'ä¸ªäºº'),
                            'bot': ('ğŸ¤–', 'æœºå™¨äºº')
                        }.get(chat_type, ('ğŸ“Œ', 'ç›®æ ‡'))
                        
                        type_icon, type_name = type_info
                        chat_name_escaped = html.escape(str(chat_name))
                        chat_id_escaped = html.escape(str(chat_id_display))
                        username_str = f" @{html.escape(str(username))}" if username else ""
                        text += f"â€¢ {type_icon} <b>{chat_name_escaped}</b> ({type_name}) <code>{chat_id_escaped}</code>{username_str}\n"
                    else:
                        chat_id_escaped = html.escape(str(chat_id))
                        text += f"â€¢ ğŸ“Œ <b>ç›®æ ‡</b> (<code>{chat_id_escaped}</code>)\n"
                if len(push_chats) > 5:
                    text += f"â€¢ ... è¿˜æœ‰ {len(push_chats) - 5} ä¸ª\n"
            else:
                text += "â€¢ æš‚æ— \n"
            text += "\n"
            
            text += "ğŸ” <b>ç­›é€‰æ¡ä»¶</b>\n"
            filters_cfg = task_cfg.get("filters", {})
            filter_names = {
                "market_cap_usd": "å¸‚å€¼(USD)",
                "liquidity_usd": "æ± å­(USD)",
                "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
                "top10_ratio": "å‰åå æ¯”",
                "holder_count": "æŒæœ‰äººæ•°",
                "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯”",
                "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
                "sol_sniffer_score": "SolSnifferè¯„åˆ†",
                "token_sniffer_score": "TokenSnifferè¯„åˆ†",
            }
            has_filter = False
            for key, display_name in filter_names.items():
                f = filters_cfg.get(key, {})
                min_v = f.get("min")
                max_v = f.get("max")
                if min_v is not None or max_v is not None:
                    has_filter = True
                    min_str = f"{min_v:,.0f}" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v:,.0f}" if max_v is not None else "æ— é™åˆ¶"
                    # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼Œä½¿ç”¨æ›´ç²¾ç¡®çš„æ ¼å¼
                    if key in ["top10_ratio", "max_holder_ratio"]:
                        min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— é™åˆ¶"
                        max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— é™åˆ¶"
                    text += f"â€¢ {display_name}: {min_str} ~ {max_str}\n"
            if not has_filter:
                text += "â€¢ æœªè®¾ç½®\n"
            text += "\n"
        
        await update.message.reply_text(text, parse_mode="HTML")

    async def cmd_tasks(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not self.scheduler:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦ï¼ˆç¼ºå°‘é…ç½®æˆ–å¯åŠ¨å¤±è´¥ï¼‰")
            return
        tasks = self.scheduler.list_tasks()
        if not tasks:
            await update.message.reply_text("ğŸ“‹ å½“å‰æ— ä»»åŠ¡")
            return
        lines = ["ğŸ“‹ ä»»åŠ¡åˆ—è¡¨:"]
        for t in tasks:
            status = "âœ… å¯ç”¨" if t.get("enabled") else "â¸ï¸ æš‚åœ"
            lines.append(f"- {t.get('id')} | {t.get('name')} | {status} | æ¯{t.get('interval_minutes')}åˆ†é’Ÿ | client={t.get('client')}")
        await update.message.reply_text("\n".join(lines))

    async def cmd_task_pause(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not self.scheduler:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦")
            return
        if not context.args:
            await update.message.reply_text("ç”¨æ³•: /task_pause <task_id>")
            return
        task_id = context.args[0]
        ok = self.scheduler.pause(task_id)
        await update.message.reply_text("âœ… å·²æš‚åœ" if ok else "âŒ æœªæ‰¾åˆ°ä»»åŠ¡")

    async def cmd_task_resume(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not self.scheduler:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦")
            return
        if not context.args:
            await update.message.reply_text("ç”¨æ³•: /task_resume <task_id>")
            return
        task_id = context.args[0]
        ok = self.scheduler.resume(task_id)
        await update.message.reply_text("âœ… å·²æ¢å¤" if ok else "âŒ æœªæ‰¾åˆ°ä»»åŠ¡")

    async def cmd_add_client(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not self.scheduler or not self.scheduler.client_pool:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦/å®¢æˆ·ç«¯æ± ")
            return
        # ç”¨æ³•: /add_client <name> <session>
        if len(context.args) < 2:
            await update.message.reply_text("ç”¨æ³•: /add_client <name> <session_path æˆ– string_session>")
            return
        name = context.args[0]
        session_path = " ".join(context.args[1:])
        try:
            final_name = await self.scheduler.client_pool.add_client(name, session_path)
        except Exception as e:
            await update.message.reply_text(f"âŒ æ·»åŠ å¤±è´¥: {e}\nâš™ï¸ è¯·ç¡®è®¤ .env å·²è®¾ç½® TELEGRAM_API_ID / TELEGRAM_API_HASH")
            return
        await update.message.reply_text(f"âœ… å®¢æˆ·ç«¯å·²æ·»åŠ å¹¶å¯åŠ¨ï¼š{final_name}")

    async def cmd_add_task(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not self.scheduler:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦")
            return
        # ç”¨æ³•: /add_task <id> <client> <chain> <ca> <interval_minutes> <targets_csv>
        if len(context.args) < 6:
            await update.message.reply_text("ç”¨æ³•: /add_task <id> <client> <chain> <ca> <interval_minutes> <targets_csv>")
            return
        task_id = context.args[0]
        client = context.args[1]
        chain = context.args[2]
        ca = context.args[3]
        try:
            interval = int(context.args[4])
        except Exception:
            await update.message.reply_text("âŒ interval_minutes éœ€è¦æ˜¯æ•°å­—")
            return
        targets_csv = context.args[5]
        targets = [t.strip() for t in targets_csv.split(",") if t.strip()]
        task = {
            "id": task_id,
            "name": task_id,
            "client": client,
            "chain": chain,
            "ca": ca,
            "targets": targets,
            "interval_minutes": interval,
            "enabled": True,
        }
        ok = self.scheduler.add_task(task)
        await update.message.reply_text("âœ… ä»»åŠ¡å·²æ·»åŠ " if ok else "âŒ ä»»åŠ¡IDå·²å­˜åœ¨")

    async def cmd_add_listen(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        chat_id = None
        if context.args:
            try:
                chat_id = int(context.args[0])
            except Exception:
                await update.message.reply_text("âŒ ç”¨æ³•: `/add_listen [chat_id]`\næ— å‚æ•°åˆ™æ·»åŠ å½“å‰ç¾¤", parse_mode="Markdown")
                return
        else:
            chat_id = update.effective_chat.id if update.effective_chat else None
        if chat_id is None:
            await update.message.reply_text("âŒ æ— æ³•è·å–ç¾¤ç»„ID")
            return
        await self.state.add_listen(chat_id)
        await update.message.reply_text(f"âœ… å·²æ·»åŠ ç›‘å¬ç¾¤: `{chat_id}`\n\nğŸ’¡ ä½¿ç”¨ `/list_listen` æŸ¥çœ‹æ‰€æœ‰ç›‘å¬ç¾¤", parse_mode="Markdown")

    async def cmd_del_listen(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not context.args:
            await update.message.reply_text("âŒ ç”¨æ³•: `/del_listen <chat_id>`", parse_mode="Markdown")
            return
        try:
            chat_id = int(context.args[0])
        except Exception:
            await update.message.reply_text("âŒ æ— æ•ˆçš„chat_id")
            return
        snap = await self.state.snapshot()
        if chat_id not in snap.get("listen_chats", []):
            await update.message.reply_text(f"âŒ ç›‘å¬åˆ—è¡¨ä¸­ä¸å­˜åœ¨: `{chat_id}`", parse_mode="Markdown")
            return
        await self.state.del_listen(chat_id)
        await update.message.reply_text(f"âœ… å·²åˆ é™¤ç›‘å¬ç¾¤: `{chat_id}`", parse_mode="Markdown")

    async def cmd_list_listen(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        snap = await self.state.snapshot()
        listen_chats = snap.get("listen_chats", [])
        if not listen_chats:
            await update.message.reply_text("ğŸ“‹ <b>ç›‘å¬ç¾¤ç»„åˆ—è¡¨</b>\n\næš‚æ— ç›‘å¬ç¾¤ç»„\n\nğŸ’¡ ä½¿ç”¨ <code>/add_listen</code> æ·»åŠ ", parse_mode="HTML")
            return
        text = f"ğŸ“‹ <b>ç›‘å¬ç¾¤ç»„åˆ—è¡¨</b> ({len(listen_chats)}ä¸ª)\n\n"
        for idx, chat_id in enumerate(listen_chats, 1):
            chat_info = await self._get_chat_info(chat_id)
            chat_name = chat_info.get('title', f'ç›®æ ‡ {chat_id}') if chat_info else f'ç›®æ ‡ {chat_id}'
            chat_name_escaped = html.escape(str(chat_name))
            chat_id_escaped = html.escape(str(chat_id))
            text += f"{idx}. <b>{chat_name_escaped}</b>\n   ID: <code>{chat_id_escaped}</code>\n\n"
        text += "ğŸ’¡ ä½¿ç”¨ <code>/del_listen &lt;chat_id&gt;</code> åˆ é™¤"
        await update.message.reply_text(text, parse_mode="HTML")

    async def cmd_add_push(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        chat_id = None
        if context.args:
            try:
                chat_id = int(context.args[0])
            except Exception:
                await update.message.reply_text("âŒ ç”¨æ³•: `/add_push [chat_id]`\næ— å‚æ•°åˆ™æ·»åŠ å½“å‰ç¾¤", parse_mode="Markdown")
                return
        else:
            chat_id = update.effective_chat.id if update.effective_chat else None
        if chat_id is None:
            await update.message.reply_text("âŒ æ— æ³•è·å–ç¾¤ç»„ID")
            return
        await self.state.add_push(chat_id)
        await update.message.reply_text(f"âœ… å·²æ·»åŠ æ¨é€ç¾¤: `{chat_id}`\n\nğŸ’¡ ä½¿ç”¨ `/list_push` æŸ¥çœ‹æ‰€æœ‰æ¨é€ç¾¤", parse_mode="Markdown")

    async def cmd_del_push(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if not context.args:
            await update.message.reply_text("âŒ ç”¨æ³•: `/del_push <chat_id>`", parse_mode="Markdown")
            return
        try:
            chat_id = int(context.args[0])
        except Exception:
            await update.message.reply_text("âŒ æ— æ•ˆçš„chat_id")
            return
        snap = await self.state.snapshot()
        if chat_id not in snap.get("push_chats", []):
            await update.message.reply_text(f"âŒ æ¨é€åˆ—è¡¨ä¸­ä¸å­˜åœ¨: `{chat_id}`", parse_mode="Markdown")
            return
        await self.state.del_push(chat_id)
        await update.message.reply_text(f"âœ… å·²åˆ é™¤æ¨é€ç¾¤: `{chat_id}`", parse_mode="Markdown")

    async def cmd_list_push(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        snap = await self.state.snapshot()
        push_chats = snap.get("push_chats", [])
        if not push_chats:
            await update.message.reply_text("ğŸ“‹ <b>æ¨é€ç¾¤ç»„åˆ—è¡¨</b>\n\næš‚æ— æ¨é€ç¾¤ç»„\n\nğŸ’¡ ä½¿ç”¨ <code>/add_push</code> æ·»åŠ ", parse_mode="HTML")
            return
        text = f"ğŸ“‹ <b>æ¨é€ç¾¤ç»„åˆ—è¡¨</b> ({len(push_chats)}ä¸ª)\n\n"
        for idx, chat_id in enumerate(push_chats, 1):
            chat_info = await self._get_chat_info(chat_id)
            if chat_info:
                chat_name = chat_info.get('title', f'ç›®æ ‡ {chat_id}')
                chat_type = chat_info.get('type', 'unknown')
                username = chat_info.get('username')
                chat_id_display = chat_info.get('id', chat_id)
                
                # ç±»å‹å›¾æ ‡å’Œåç§°
                type_info = {
                    'group': ('ğŸ‘¥', 'ç¾¤ç»„'),
                    'supergroup': ('ğŸ‘¥', 'ç¾¤ç»„'),
                    'channel': ('ğŸ“¢', 'é¢‘é“'),
                    'private': ('ğŸ‘¤', 'ä¸ªäºº'),
                    'bot': ('ğŸ¤–', 'æœºå™¨äºº')
                }.get(chat_type, ('ğŸ“Œ', 'ç›®æ ‡'))
                
                type_icon, type_name = type_info
                chat_name_escaped = html.escape(str(chat_name))
                chat_id_escaped = html.escape(str(chat_id_display))
                username_str = f" @{html.escape(str(username))}" if username else ""
                text += f"{idx}. {type_icon} <b>{chat_name_escaped}</b> ({type_name})\n   ID: <code>{chat_id_escaped}</code>{username_str}\n\n"
            else:
                chat_name = f'ç¾¤ç»„ {chat_id}'
                chat_name_escaped = html.escape(str(chat_name))
                chat_id_escaped = html.escape(str(chat_id))
                text += f"{idx}. <b>{chat_name_escaped}</b>\n   ID: <code>{chat_id_escaped}</code>\n\n"
        text += "ğŸ’¡ ä½¿ç”¨ <code>/del_push &lt;chat_id&gt;</code> åˆ é™¤"
        await update.message.reply_text(text, parse_mode="HTML")

    async def cmd_set_filter(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        if len(context.args) != 3:
            await update.message.reply_text(
                "âŒ ç”¨æ³•: `/set_filter <åç§°> <æœ€å°å€¼|null> <æœ€å¤§å€¼|null>`\n\n"
                "ğŸ’¡ ç¤ºä¾‹:\n"
                "`/set_filter market_cap_usd 5000 1000000` - å¸‚å€¼5K-1M\n"
                "`/set_filter top10_ratio null 0.3` - å‰åå æ¯”<30%\n\n"
                "ä½¿ç”¨ `/list_filters` æŸ¥çœ‹æ‰€æœ‰ç­›é€‰æ¡ä»¶",
                parse_mode="Markdown"
            )
            return
        name, min_s, max_s = context.args
        # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼ˆå‰åå æ¯”/æœ€å¤§æŒä»“ï¼‰ï¼Œè¾“å…¥ç”¨ 1-100 çš„æ•´æ•°ï¼Œå†…éƒ¨ä»¥ 0-1 å­˜å‚¨
        if name in ("top10_ratio", "max_holder_ratio"):
            def parse_pct(s: str):
                """å…è®¸ 0-100ï¼Œå¯å¸¦ä¸€ä½å°æ•°ï¼ˆå¦‚ 2.5 -> 2.5%ï¼‰"""
                if s.lower() == "null":
                    return None
                try:
                    fv = float(s)
                except Exception:
                    raise ValueError("percent must be number 0-100 (one decimal allowed)")
                # å…è®¸åˆ°ä¸€ä½å°æ•°
                if abs(fv * 10 - round(fv * 10)) > 0.0001:
                    raise ValueError("percent precision up to 0.1 (e.g. 2.5)")
                if fv < 0 or fv > 100:
                    raise ValueError("percent must be between 0 and 100")
                return fv / 100.0
            try:
                min_v = parse_pct(min_s)
                max_v = parse_pct(max_s)
            except Exception as e:
                await update.message.reply_text(f"âŒ è®¾ç½®å¤±è´¥: {e}")
                return
        else:
            min_v = None if min_s.lower() == "null" else _maybe_float(min_s)
            max_v = None if max_s.lower() == "null" else _maybe_float(max_s)
            if name in ("sol_sniffer_score", "token_sniffer_score"):
                for label, val in (("æœ€å°å€¼", min_v), ("æœ€å¤§å€¼", max_v)):
                    if val is not None and (val < 0 or val > 100):
                        await update.message.reply_text(f"âŒ {label}éœ€åœ¨ 0-100 ä¹‹é—´")
                        return
        try:
            await self.state.set_filter(name, min_v, max_v)
        except Exception as e:
            await update.message.reply_text(f"âŒ è®¾ç½®å¤±è´¥: {e}")
            return
        
        filter_names = {
            "market_cap_usd": "å¸‚å€¼(USD)",
            "liquidity_usd": "æ± å­(USD)",
            "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
            "top10_ratio": "å‰åå æ¯”",
            "holder_count": "æŒæœ‰äººæ•°",
            "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯”",
            "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
            "sol_sniffer_score": "SolSnifferè¯„åˆ†",
            "token_sniffer_score": "TokenSnifferè¯„åˆ†",
        }
        display_name = filter_names.get(name, name)
        # æ ¼å¼åŒ–æ˜¾ç¤ºï¼šç™¾åˆ†æ¯”ç±»å‹æ˜¾ç¤ºä¸ºç™¾åˆ†å·å¹¶ä¿ç•™ä¸€ä½å°æ•°
        if name in ("top10_ratio", "max_holder_ratio"):
            min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— é™åˆ¶"
            max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— é™åˆ¶"
        else:
            min_str = f"{min_v:,.0f}" if min_v is not None else "æ— é™åˆ¶"
            max_str = f"{max_v:,.0f}" if max_v is not None else "æ— é™åˆ¶"
        await update.message.reply_text(
            f"âœ… ç­›é€‰æ¡ä»¶å·²æ›´æ–°\n\n"
            f"**{display_name}** ({name})\n"
            f"æœ€å°å€¼: {min_str}\n"
            f"æœ€å¤§å€¼: {max_str}",
            parse_mode="Markdown"
        )

    async def cmd_list_filters(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id not in self.admin_ids:
            await update.message.reply_text("âŒ æ— æƒé™")
            return
        filters_cfg = (await self.state.filters_cfg()).dict()
        
        filter_names = {
            "market_cap_usd": "å¸‚å€¼(USD)",
            "liquidity_usd": "æ± å­(USD)",
            "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
            "top10_ratio": "å‰åå æ¯” (0-1)",
            "holder_count": "æŒæœ‰äººæ•°",
            "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯” (0-1)",
            "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
            "sol_sniffer_score": "SolSnifferè¯„åˆ† (0-100)",
            "token_sniffer_score": "TokenSnifferè¯„åˆ† (0-100)",
        }
        
        text = "ğŸ” **ç­›é€‰æ¡ä»¶åˆ—è¡¨**\n\n"
        has_set = False
        for key, display_name in filter_names.items():
            f = filters_cfg.get(key, {})
            min_v = f.get("min")
            max_v = f.get("max")
            if min_v is None and max_v is None:
                text += f"â€¢ **{display_name}** (`{key}`): âŒ æœªè®¾ç½®\n"
            else:
                has_set = True
                # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼Œæ˜¾ç¤ºä¸ºç™¾åˆ†å·
                if key in ["top10_ratio", "max_holder_ratio"]:
                    min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— é™åˆ¶"
                else:
                    min_str = f"{min_v:,.2f}" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v:,.2f}" if max_v is not None else "æ— é™åˆ¶"
                text += f"â€¢ **{display_name}** (`{key}`): âœ… {min_str} ~ {max_str}\n"
        
        if not has_set:
            text += "\nâš ï¸ æ‰€æœ‰ç­›é€‰æ¡ä»¶å‡æœªè®¾ç½®ï¼Œæ‰€æœ‰CAéƒ½ä¼šæ¨é€\n"
        
        text += "\nğŸ’¡ ä½¿ç”¨ `/set_filter <åç§°> <æœ€å°å€¼|null> <æœ€å¤§å€¼|null>` è®¾ç½®"
        await update.message.reply_text(text, parse_mode="Markdown")

    async def on_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id if update.effective_user else None
        is_admin = user_id in self.admin_ids
        chat_id = update.effective_chat.id if update.effective_chat else None
        if chat_id is None:
            return
        
        text = update.message.text if update.message else ""
        if not text:
            return
        
        # å¤„ç†ç®¡ç†å‘˜æŒ‰é’®èœå•
        if is_admin and chat_id == user_id:  # ç§èŠä¸­çš„æŒ‰é’®/é…ç½®è¾“å…¥
            await self.handle_admin_button(update, context, text)
            return
        
        # å¤„ç†CAç›‘å¬ï¼ˆç¾¤ç»„æ¶ˆæ¯ï¼‰
        if not self.process_ca:
            return
        snap = await self.state.snapshot()
        tasks = snap.get("tasks", {})
        if not tasks:
            logger.debug("â­ï¸  No tasks configured, ignoring message")
            return

        # æ‰¾åˆ°åŒ…å«è¯¥ç›‘å¬ç¾¤çš„å·²å¯ç”¨ä»»åŠ¡
        matched_tasks = []
        for tid, cfg in tasks.items():
            if cfg.get("enabled") and chat_id in cfg.get("listen_chats", []):
                matched_tasks.append(tid)

        if not matched_tasks:
            logger.debug(f"â­ï¸  Chat {chat_id} not in any enabled task listen list")
            return
        
        logger.info(f"ğŸ“¨ Message received from chat {chat_id} for tasks: {matched_tasks}")
        found = set(CA_PATTERN.findall(text))
        logger.info(f"ğŸ” Found {len(found)} CA(s) in message: {[ca[:8] + '...' for ca in found]}")
        
        for ca in found:
            # æ¯ä¸ªä»»åŠ¡ç‹¬ç«‹åå°å¤„ç†ï¼Œé¿å…é˜»å¡
            for tid in matched_tasks:
                asyncio.create_task(self._process_ca_bg(chain_hint(ca), ca, task_id=tid))
    
    async def handle_admin_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str):
        """å¤„ç†ç®¡ç†å‘˜æŒ‰é’®èœå•"""
        # å…ˆå¤„ç†é€šç”¨â€œå®Œæˆâ€æŒ‡ä»¤ï¼ˆç»“æŸç­‰å¾…çŠ¶æ€ï¼‰
        user_id = update.effective_user.id
        if text.strip() in ("å®Œæˆ", "å®Œæ¯•", "done", "Done", "DONE"):
            if hasattr(context, 'user_data') and context.user_data.get(f'{user_id}_waiting'):
                context.user_data[f'{user_id}_waiting'] = None
                await update.message.reply_text("âœ… å·²ç»“æŸå½“å‰é…ç½®æµç¨‹")
                return

        if text == "ğŸ“Š æŸ¥çœ‹é…ç½®":
            await self.cmd_settings(update, context)
        elif text == "ğŸ‘¥ ç›‘å¬ç¾¤ç»„":
            await self.show_listen_menu(update.message)
        elif text == "ğŸ“¤ æ¨é€ç›®æ ‡":
            await self.show_push_menu(update.message)
        elif text == "ğŸ” ç­›é€‰æ¡ä»¶":
            await self.show_filter_menu(update.message)
        elif text == "ğŸ“‹ æŸ¥çœ‹ä»»åŠ¡":
            await self.show_task_list_message(update.message)
        elif text == "ğŸ—“ï¸ ä»»åŠ¡ç®¡ç†":
            await self.show_task_menu(update.message)
        else:
            # å¯èƒ½æ˜¯è¾“å…¥çš„å€¼ï¼ˆç”¨äºè®¾ç½®ç­›é€‰æ¡ä»¶ï¼‰
            # æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„è®¾ç½®
            if hasattr(context, 'user_data') and context.user_data.get(f'{user_id}_waiting'):
                await self.handle_setting_input(update, context, text)
    
    async def show_listen_menu(self, message):
        """æ˜¾ç¤ºç›‘å¬ç¾¤ç»„èœå•"""
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        if not current:
            await message.reply_text("âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œç„¶åå†é…ç½®ç›‘å¬ç¾¤ç»„ã€‚", parse_mode="HTML")
            return
        listen_chats = snap.get("tasks", {}).get(current, {}).get("listen_chats", [])
        
        keyboard = [
            [InlineKeyboardButton("â• æ·»åŠ ç¾¤ç»„", callback_data="add_listen_link")],
            [InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹åˆ—è¡¨", callback_data="list_listen")],
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        count = len(listen_chats)
        await message.reply_text(
            f"ğŸ‘¥ <b>ç›‘å¬ç¾¤ç»„ç®¡ç†</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n\nå½“å‰æœ‰ <b>{count}</b> ä¸ªç›‘å¬ç¾¤ç»„\n\n"
            f"ğŸ’¡ ç‚¹å‡»ã€Œæ·»åŠ ç¾¤ç»„ã€åï¼Œå‘é€ç¾¤ç»„é‚€è¯·é“¾æ¥æˆ–å…¬å…±ç¾¤é“¾æ¥",
            parse_mode="HTML",
            reply_markup=reply_markup
        )
    
    async def show_push_menu(self, message):
        """æ˜¾ç¤ºæ¨é€ç›®æ ‡èœå•ï¼ˆç¾¤ç»„/æœºå™¨äºº/ä¸ªäººï¼‰"""
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        if not current:
            await message.reply_text("âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œç„¶åå†é…ç½®æ¨é€ç›®æ ‡ã€‚", parse_mode="HTML")
            return
        push_chats = snap.get("tasks", {}).get(current, {}).get("push_chats", [])
        
        keyboard = [
            [InlineKeyboardButton("â• æ·»åŠ ç›®æ ‡", callback_data="add_push_link")],
            [InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹åˆ—è¡¨", callback_data="list_push")],
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        count = len(push_chats)
        await message.reply_text(
            f"ğŸ“¤ <b>æ¨é€ç›®æ ‡ç®¡ç†</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n\nå½“å‰æœ‰ <b>{count}</b> ä¸ªæ¨é€ç›®æ ‡ï¼ˆç¾¤ç»„/æœºå™¨äºº/ä¸ªäººï¼‰\n\n"
            f"ğŸ’¡ ç‚¹å‡»ã€Œæ·»åŠ ç›®æ ‡ã€åï¼Œå‘é€ç¾¤ç»„/æœºå™¨äººçš„é‚€è¯·é“¾æ¥ã€@ç”¨æˆ·åæˆ–chat_idï¼ˆæ•°å­—ï¼‰",
            parse_mode="HTML",
            reply_markup=reply_markup
        )
    
    async def show_filter_menu(self, message, edit: bool = False):
        """æ˜¾ç¤ºç­›é€‰æ¡ä»¶èœå•ï¼Œæ˜¾ç¤ºå·²è®¾ç½®çš„å€¼"""
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        if not current:
            text = "âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œç„¶åå†é…ç½®ç­›é€‰æ¡ä»¶ã€‚"
            if edit:
                await message.edit_message_text(text, parse_mode="HTML")
            else:
                await message.reply_text(text, parse_mode="HTML")
            return
        
        filters_cfg = snap.get("tasks", {}).get(current, {}).get("filters", {})
        
        filter_names = {
            "market_cap_usd": "ğŸ’° å¸‚å€¼(USD)",
            "liquidity_usd": "ğŸ’§ æ± å­(USD)",
            "open_minutes": "â° å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
            "top10_ratio": "ğŸ‘‘ å‰åå æ¯”",
            "holder_count": "ğŸ‘¥ æŒæœ‰äººæ•°",
            "max_holder_ratio": "ğŸ³ æœ€å¤§æŒä»“å æ¯”",
            "trades_5m": "ğŸ“ˆ 5åˆ†é’Ÿäº¤æ˜“æ•°",
            "sol_sniffer_score": "ğŸ›¡ï¸ SolSnifferè¯„åˆ†",
            "token_sniffer_score": "ğŸ›¡ï¸ TokenSnifferè¯„åˆ†",
        }
        
        # æ„å»ºèœå•æ–‡æœ¬ï¼Œæ˜¾ç¤ºå·²è®¾ç½®çš„å€¼
        text = f"ğŸ” <b>ç­›é€‰æ¡ä»¶è®¾ç½®</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n\n"
        
        keyboard = []
        for key, name in filter_names.items():
            f = filters_cfg.get(key, {})
            min_v = f.get("min")
            max_v = f.get("max")
            
            # åœ¨æŒ‰é’®åç§°åæ˜¾ç¤ºå·²è®¾ç½®çš„å€¼
            if min_v is not None or max_v is not None:
                # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼Œæ˜¾ç¤ºä¸ºç™¾åˆ†å·ï¼ˆ0.23 -> 23.0%ï¼‰
                if key in ["top10_ratio", "max_holder_ratio"]:
                    min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— "
                    max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— "
                else:
                    min_str = f"{min_v:,.0f}" if min_v is not None else "æ— "
                    max_str = f"{max_v:,.0f}" if max_v is not None else "æ— "
                button_text = f"{name} ({min_str}~{max_str})"
            else:
                button_text = f"{name} (æœªè®¾ç½®)"
            
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"set_filter_{key}")])
        
        keyboard.append([InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹æ‰€æœ‰ç­›é€‰æ¡ä»¶", callback_data="list_filters")])
        keyboard.append([InlineKeyboardButton("ğŸ”„ é‡ç½®æ‰€æœ‰ç­›é€‰", callback_data="reset_filters")])
        keyboard.append([InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_task_menu")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if edit:
            await message.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)
        else:
            await message.reply_text(text, parse_mode="HTML", reply_markup=reply_markup)

    async def show_task_menu(self, message):
        """æ˜¾ç¤ºä»»åŠ¡ç®¡ç†èœå•"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹ä»»åŠ¡", callback_data="list_tasks")],
            [InlineKeyboardButton("ğŸ‘¤ å®¢æˆ·ç«¯åˆ—è¡¨", callback_data="list_clients")],
            [InlineKeyboardButton("â• æ·»åŠ å®¢æˆ·ç«¯", callback_data="add_client_prompt")],
            [InlineKeyboardButton("â• æ·»åŠ ä»»åŠ¡", callback_data="add_task_prompt")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        text = "ğŸ—“ï¸ <b>ä»»åŠ¡ç®¡ç†</b>\n\næ”¯æŒå¤šå®¢æˆ·ç«¯ã€å¤šä»»åŠ¡å®šæ—¶æ¨é€ã€‚\nè¯·é€‰æ‹©æ“ä½œï¼š"
        # åˆ¤æ–­æ˜¯ Update å¯¹è±¡è¿˜æ˜¯ CallbackQuery å¯¹è±¡
        if hasattr(message, 'edit_message_text'):
            # æ˜¯ CallbackQueryï¼Œä½¿ç”¨ edit_message_text
            await message.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)
        else:
            # æ˜¯ Message å¯¹è±¡ï¼Œä½¿ç”¨ reply_text
            await message.reply_text(text, parse_mode="HTML", reply_markup=reply_markup)
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†å†…è”æŒ‰é’®å›è°ƒ"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id not in self.admin_ids:
            await query.edit_message_text("âŒ æ— æƒé™")
            return
        
        data = query.data
        
        # ç›‘å¬ç¾¤ç»„
        if data == "add_listen_link":
            await query.edit_message_text("ğŸ“ è¯·å‘é€ç¾¤ç»„é‚€è¯·é“¾æ¥æˆ–å…¬å…±ç¾¤é“¾æ¥ï¼š\n\næ ¼å¼ï¼š\nâ€¢ `https://t.me/joinchat/...` (ç§æœ‰ç¾¤)\nâ€¢ `https://t.me/groupname` (å…¬å…±ç¾¤)\nâ€¢ æˆ–ç›´æ¥å‘é€ç¾¤ç»„IDï¼ˆæ•°å­—ï¼‰")
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = 'add_listen_link'
        elif data.startswith("del_listen_"):
            # æ”¯æŒæ•°å­—IDå’Œ@usernameï¼Œä¸èƒ½ç®€å• split å†è½¬ int
            raw_id = data[len("del_listen_"):]
            chat_key: object
            if raw_id.lstrip("-").isdigit():
                chat_key = int(raw_id)
            else:
                chat_key = raw_id  # ä¾‹å¦‚ @some_bot æˆ– @channel_name
            await self.state.del_listen(chat_key)
            await query.edit_message_text(f"âœ… å·²åˆ é™¤ç›‘å¬ç¾¤: <code>{html.escape(str(chat_key))}</code>", parse_mode="HTML")
        elif data == "list_listen":
            await self.list_listen_callback(query)
        elif data == "back_listen":
            await self.show_listen_menu(query.message)
        
        # æ¨é€ç¾¤ç»„
        elif data == "add_push_link":
            await query.edit_message_text(
                "ğŸ“ è¯·å‘é€æ¨é€ç›®æ ‡ï¼š\n\n"
                "â€¢ ç¾¤ç»„/æœºå™¨äººçš„é‚€è¯·é“¾æ¥\n"
                "â€¢ @ç”¨æˆ·å\n"
                "â€¢ chat_idï¼ˆæ•°å­—ï¼Œå¯ä¸ºè´Ÿæ•°ï¼‰",
                parse_mode="HTML"
            )
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = 'add_push_link'
        elif data.startswith("del_push_"):
            # æ”¯æŒæ•°å­—IDå’Œ@usernameï¼Œä¸èƒ½ç®€å• split å†è½¬ int
            raw_id = data[len("del_push_"):]
            chat_key: object
            if raw_id.lstrip("-").isdigit():
                chat_key = int(raw_id)
            else:
                chat_key = raw_id  # ä¾‹å¦‚ @some_bot æˆ– @channel_name
            await self.state.del_push(chat_key)
            await query.edit_message_text(f"âœ… å·²åˆ é™¤æ¨é€ç›®æ ‡: <code>{html.escape(str(chat_key))}</code>", parse_mode="HTML")
        elif data == "list_push":
            await self.list_push_callback(query)
        elif data == "back_push":
            await self.show_push_menu(query.message)
        
        # ç­›é€‰æ¡ä»¶
        elif data.startswith("set_filter_"):
            filter_key = data.replace("set_filter_", "")
            # ä½¿ç”¨HTMLæ¨¡å¼é¿å…Markdownè§£æé”™è¯¯
            filter_names = {
                "market_cap_usd": "å¸‚å€¼(USD)",
                "liquidity_usd": "æ± å­(USD)",
                "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
                "top10_ratio": "å‰åå æ¯”",
                "holder_count": "æŒæœ‰äººæ•°",
                "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯”",
                "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
                "sol_sniffer_score": "SolSnifferè¯„åˆ†",
                "token_sniffer_score": "TokenSnifferè¯„åˆ†",
            }
            display_name = filter_names.get(filter_key, filter_key)
            
            # è·å–å½“å‰å·²è®¾ç½®çš„å€¼
            snap = await self.state.snapshot()
            current = snap.get("current_task")
            filters_cfg = snap.get("tasks", {}).get(current, {}).get("filters", {}) if current else {}
            f = filters_cfg.get(filter_key, {})
            current_min = f.get("min")
            current_max = f.get("max")
            
                # æ˜¾ç¤ºå½“å‰å€¼
            current_text = ""
            if current_min is not None or current_max is not None:
                    # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼Œæ˜¾ç¤ºç™¾åˆ†å·å¹¶ä¿ç•™ä¸€ä½å°æ•°
                    if filter_key in ["top10_ratio", "max_holder_ratio"]:
                        min_str = f"{current_min*100:.1f}%" if current_min is not None else "æ— é™åˆ¶"
                        max_str = f"{current_max*100:.1f}%" if current_max is not None else "æ— é™åˆ¶"
                    else:
                        min_str = f"{current_min:,.0f}" if current_min is not None else "æ— é™åˆ¶"
                        max_str = f"{current_max:,.0f}" if current_max is not None else "æ— é™åˆ¶"
                    current_text = f"\n\nå½“å‰è®¾ç½®ï¼š<b>{min_str} ~ {max_str}</b>"
            
            # æ ¹æ®ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤ºï¼ˆç™¾åˆ†æ¯”ç±»ä½¿ç”¨ 1-100 çš„æ•´æ•°ï¼‰
            if filter_key == "max_holder_ratio":
                hint = "ä¾‹å¦‚ï¼š<code>1 20</code> æˆ– <code>null 15</code>ï¼ˆè¾“å…¥ 0-100ï¼Œå¯å¸¦ä¸€ä½å°æ•°ï¼Œå¦‚ 2.5 è¡¨ç¤º 2.5%ï¼‰"
            elif filter_key in ["top10_ratio"]:
                hint = "ä¾‹å¦‚ï¼š<code>1 30</code> æˆ– <code>null 20</code>ï¼ˆè¾“å…¥ 0-100ï¼Œå¯å¸¦ä¸€ä½å°æ•°ï¼Œå¦‚ 2.5 è¡¨ç¤º 2.5%ï¼‰"
            elif filter_key in ("sol_sniffer_score", "token_sniffer_score"):
                hint = "ä¾‹å¦‚ï¼š<code>60 90</code> æˆ– <code>null 80</code>ï¼ˆè¾“å…¥ 0-100ï¼‰"
            else:
                hint = "ä¾‹å¦‚ï¼š<code>5000 1000000</code> æˆ– <code>null 15</code>"
            
            await query.edit_message_text(
                f"ğŸ“ è®¾ç½®ç­›é€‰æ¡ä»¶: <b>{display_name}</b>{current_text}\n\n"
                f"è¯·è¾“å…¥èŒƒå›´ï¼Œæ ¼å¼ï¼š<code>æœ€å°å€¼ æœ€å¤§å€¼</code>\n"
                f"{hint}\n\n"
                f"ğŸ’¡ ä½¿ç”¨ <code>null</code> è¡¨ç¤ºæ— é™åˆ¶\n"
                f"ğŸ’¡ è®¾ç½®å®Œæˆåä¼šè‡ªåŠ¨è¿”å›èœå•ï¼Œå¯ç»§ç»­è®¾ç½®å…¶ä»–æ¡ä»¶",
                parse_mode="HTML"
            )
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = f'set_filter_{filter_key}'
            context.user_data[f'{user_id}_filter_menu_query'] = query  # ä¿å­˜queryä»¥ä¾¿è¿”å›èœå•
        elif data == "list_filters":
            await self.list_filters_callback(query)
        elif data == "reset_filters":
            # é‡ç½®æ‰€æœ‰ç­›é€‰æ¡ä»¶
            filter_keys = [
                "market_cap_usd",
                "liquidity_usd",
                "open_minutes",
                "top10_ratio",
                "holder_count",
                "max_holder_ratio",
                "trades_5m",
                "sol_sniffer_score",
                "token_sniffer_score",
            ]
            for key in filter_keys:
                await self.state.set_filter(key, None, None)
            await query.edit_message_text("âœ… å·²é‡ç½®å½“å‰ä»»åŠ¡çš„æ‰€æœ‰ç­›é€‰æ¡ä»¶")
        
        # ä»»åŠ¡ç®¡ç†
        elif data == "list_tasks":
            await self.list_tasks_callback(query)
        elif data == "add_client_prompt":
            await query.edit_message_text(
                "ğŸ“ <b>æ‰¹é‡æ·»åŠ å®¢æˆ·ç«¯</b>\n\n"
                "å¯ä»¥ä¸Šä¼ å¤šä¸ª session æ–‡ä»¶æˆ–å‘é€å¤šä¸ªå­—ç¬¦ä¸² sessionï¼š\n\n"
                "â€¢ ä¸Šä¼  <code>.session</code> æ–‡ä»¶ï¼ˆè‡ªåŠ¨ç”Ÿæˆåç§°ï¼‰\n"
                "â€¢ å‘é€å­—ç¬¦ä¸²ï¼š<code>åç§° sessionå­—ç¬¦ä¸²</code>\n"
                "â€¢ æˆ–ç›´æ¥å‘é€ session å­—ç¬¦ä¸²ï¼ˆè‡ªåŠ¨ç”Ÿæˆåç§°ï¼‰\n\n"
                "å®Œæˆåè¾“å…¥ï¼š<code>å®Œæˆ</code> æˆ– <code>done</code>\n\n"
                "âš™ï¸ è¯·å…ˆåœ¨ <code>.env</code> è®¾ç½® <code>TELEGRAM_API_ID</code> / <code>TELEGRAM_API_HASH</code>ï¼ˆæˆ– APP_ID / APP_HASHï¼‰ã€‚",
                parse_mode="HTML"
            )
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = 'add_client'
            context.user_data[f'{user_id}_client_count'] = 0
        elif data == "add_task_prompt":
            await query.edit_message_text(
                "ğŸ“ <b>åˆ›å»ºä»»åŠ¡</b>\n\n"
                "åªéœ€è¾“å…¥ä»»åŠ¡åç§°ï¼Œä¾‹å¦‚ï¼š<code>ä»»åŠ¡A</code>\n"
                "åˆ›å»ºåä¼šè‡ªåŠ¨åˆ‡æ¢ä¸ºå½“å‰ä»»åŠ¡ï¼Œé»˜è®¤å¤„äºâ€œæš‚åœâ€çŠ¶æ€ã€‚\n"
                "è¯·ç»§ç»­é…ç½®ï¼šç›‘å¬ç¾¤ç»„ã€æ¨é€ç›®æ ‡ã€ç­›é€‰æ¡ä»¶ï¼Œå¹¶åœ¨ä»»åŠ¡åˆ—è¡¨ä¸­å¯ç”¨ã€‚",
                parse_mode="HTML"
            )
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = 'add_task'
        elif data == "list_clients":
            await self.list_clients_callback(query)
        elif data.startswith("del_client_"):
            client_name = data.replace("del_client_", "")
            if self.scheduler and self.scheduler.client_pool:
                ok = await self.scheduler.client_pool.remove_client(client_name)
                if ok:
                    await query.answer("âœ… å®¢æˆ·ç«¯å·²åˆ é™¤")
                    await self.list_clients_callback(query)
                else:
                    await query.answer("âŒ æœªæ‰¾åˆ°è¯¥å®¢æˆ·ç«¯")
            else:
                await query.answer("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦/å®¢æˆ·ç«¯æ± ")
        elif data.startswith("task_select:"):
            task_id = data.split(":", 1)[1]
            await self.state.set_current_task(task_id)
            await query.answer(f"å·²åˆ‡æ¢åˆ°ä»»åŠ¡ {task_id}")
            await self.list_tasks_callback(query)
        elif data.startswith("task_enable:"):
            task_id = data.split(":", 1)[1]
            # æ£€æŸ¥æ—¶é—´çª—
            task_cfg = await self.state.task_settings(task_id)
            start_time = task_cfg.get("start_time")
            end_time = task_cfg.get("end_time")
            has_window = start_time or end_time
            
            if has_window:
                # æ£€æŸ¥æ˜¯å¦åœ¨æ—¶é—´çª—å†…
                in_window = self._is_in_time_window(start_time, end_time)
                if not in_window:
                    window_str = f"{start_time or 'ä¸é™åˆ¶'} ~ {end_time or 'ä¸é™åˆ¶'}"
                    await query.answer(f"âš ï¸ å½“å‰ä¸åœ¨æ—¶é—´çª—å†… ({window_str})", show_alert=True)
                    await self.list_tasks_callback(query)
                    return
            
            await self.state.set_task_enabled(task_id, True)
            # åŒæ­¥åˆ° scheduler
            if self.scheduler:
                for t in self.scheduler.tasks:
                    if t.get("id") == task_id:
                        t["enabled"] = True
                self.scheduler.client_pool.update_tasks_config(self.scheduler.tasks)
            await query.answer("å·²å¯ç”¨")
            await self.list_tasks_callback(query)
        elif data.startswith("task_disable:"):
            task_id = data.split(":", 1)[1]
            await self.state.set_task_enabled(task_id, False)
            # åŒæ­¥åˆ° scheduler
            if self.scheduler:
                for t in self.scheduler.tasks:
                    if t.get("id") == task_id:
                        t["enabled"] = False
                self.scheduler.client_pool.update_tasks_config(self.scheduler.tasks)
            await query.answer("å·²æš‚åœ")
            await self.list_tasks_callback(query)
        elif data.startswith("task_delete:"):
            task_id = data.split(":", 1)[1]
            ok = await self.state.delete_task(task_id)
            await query.answer("å·²åˆ é™¤" if ok else "æœªæ‰¾åˆ°ä»»åŠ¡")
            await self.list_tasks_callback(query)
        elif data.startswith("task_window:"):
            task_id = data.split(":", 1)[1]
            await query.edit_message_text(
                f"ğŸ•’ ä¸ºä»»åŠ¡ <b>{html.escape(task_id)}</b> è®¾ç½®æ—¶é—´çª—\n\n"
                f"è¯·è¾“å…¥ï¼š<code>HH:MM HH:MM</code>\n"
                f"ç¬¬ä¸€ä¸ªæ˜¯å¼€å§‹æ—¶é—´ï¼Œç¬¬äºŒä¸ªæ˜¯ç»“æŸæ—¶é—´ï¼›\n"
                f"ç•™ç©ºæˆ–è¾“å…¥ <code>none</code> ä»£è¡¨ä¸é™åˆ¶ã€‚\n"
                f"ä¾‹ï¼š<code>09:00 23:00</code> æˆ– <code>none 06:00</code>ã€‚",
                parse_mode="HTML"
            )
            if not hasattr(context, 'user_data'):
                context.user_data = {}
            context.user_data[f'{user_id}_waiting'] = f'set_window:{task_id}'
            # ä¿å­˜åŸå§‹ callback queryï¼ˆç”¨äºè¾“å…¥å®Œæˆæˆ–å‡ºé”™åè¿”å›ä»»åŠ¡åˆ—è¡¨å¹¶åˆ·æ–°ï¼‰
            context.user_data[f'{user_id}_window_menu_query'] = query
        elif data == "back_task_menu":
            # è¿”å›åˆ°ä»»åŠ¡ç®¡ç†èœå•
            keyboard = [
                [InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹ä»»åŠ¡", callback_data="list_tasks")],
                [InlineKeyboardButton("ğŸ‘¤ å®¢æˆ·ç«¯åˆ—è¡¨", callback_data="list_clients")],
                [InlineKeyboardButton("â• æ·»åŠ å®¢æˆ·ç«¯", callback_data="add_client_prompt")],
                [InlineKeyboardButton("â• æ·»åŠ ä»»åŠ¡", callback_data="add_task_prompt")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            text = "ğŸ—“ï¸ <b>ä»»åŠ¡ç®¡ç†</b>\n\næ”¯æŒå¤šå®¢æˆ·ç«¯ã€å¤šä»»åŠ¡å®šæ—¶æ¨é€ã€‚\nè¯·é€‰æ‹©æ“ä½œï¼š"
            await query.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)
        
    async def handle_setting_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str):
        """å¤„ç†è®¾ç½®è¾“å…¥"""
        user_id = update.effective_user.id
        if not hasattr(context, 'user_data'):
            context.user_data = {}
        waiting = context.user_data.get(f'{user_id}_waiting', '')
        
        try:
            if waiting == 'add_listen_link':
                chat_id = await self._extract_chat_id_from_link(text.strip())
                if chat_id:
                    await self.state.add_listen(chat_id)
                    chat_info = await self._get_chat_info(chat_id)
                    chat_name = chat_info.get('title', f'ç›®æ ‡ {chat_id}') if chat_info else f'ç›®æ ‡ {chat_id}'
                    chat_name_escaped = html.escape(str(chat_name))
                    chat_id_escaped = html.escape(str(chat_id))
                    await update.message.reply_text(
                        f"âœ… å·²ä¸ºå½“å‰ä»»åŠ¡æ·»åŠ ç›‘å¬ç¾¤\n\n"
                        f"<b>{chat_name_escaped}</b>\n"
                        f"ID: <code>{chat_id_escaped}</code>",
                        parse_mode="HTML"
                    )
                else:
                    await update.message.reply_text("âŒ æ— æ³•è§£æè¯¥é“¾æ¥/ç”¨æˆ·åï¼Œè¯·æ£€æŸ¥æ ¼å¼")
            elif waiting == 'add_push_link':
                chat_id = await self._extract_chat_id_from_link(text.strip())
                if chat_id:
                    await self.state.add_push(chat_id)
                    chat_info = await self._get_chat_info(chat_id)
                    chat_name = chat_info.get('title', f'ç¾¤ç»„ {chat_id}') if chat_info else f'ç¾¤ç»„ {chat_id}'
                    chat_name_escaped = html.escape(str(chat_name))
                    chat_id_escaped = html.escape(str(chat_id))
                    await update.message.reply_text(
                        f"âœ… å·²ä¸ºå½“å‰ä»»åŠ¡æ·»åŠ æ¨é€ç›®æ ‡\n\n"
                        f"<b>{chat_name_escaped}</b>\n"
                        f"ID/ç”¨æˆ·å: <code>{chat_id_escaped}</code>",
                        parse_mode="HTML"
                    )
                else:
                    await update.message.reply_text("âŒ æ— æ³•ä»é“¾æ¥ä¸­æå–ç¾¤ç»„IDï¼Œè¯·æ£€æŸ¥é“¾æ¥æ ¼å¼")
            elif waiting.startswith('set_filter_'):
                filter_key = waiting.replace('set_filter_', '')
                parts = text.strip().split()
                if len(parts) != 2:
                    await update.message.reply_text("âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·è¾“å…¥ï¼š<code>æœ€å°å€¼ æœ€å¤§å€¼</code>", parse_mode="HTML")
                    return
                
                # è§£ææœ€å°/æœ€å¤§å€¼
                # å¯¹äºç™¾åˆ†æ¯”ç±»å‹ï¼ˆå‰åå æ¯” / æœ€å¤§æŒä»“ï¼‰ï¼Œæ”¯æŒ0-100çš„å°æ•°ï¼Œå†…éƒ¨ä»¥ 0-1 å­˜å‚¨
                if filter_key in ("top10_ratio", "max_holder_ratio"):
                    def parse_pct_str(s: str):
                        if s.lower() in ("null", "none", "æ— ", "ç©º", "æ¸…ç©º", ""):
                            return None
                        try:
                            fv = float(s)
                        except Exception:
                            raise ValueError(f"ç™¾åˆ†æ¯”éœ€ä¸ºæ•°å­—ï¼ŒèŒƒå›´ 0-100ï¼š{s}")
                        if fv < 0 or fv > 100:
                            raise ValueError(f"ç™¾åˆ†æ¯”éœ€åœ¨ 0-100 ä¹‹é—´ï¼š{s}")
                        # å…è®¸åˆ°ä¸€ä½å°æ•°
                        if abs(fv * 10 - round(fv * 10)) > 0.0001:
                            raise ValueError("ç™¾åˆ†æ¯”ç²¾åº¦æœ€å¤šåˆ°0.1ä½å°æ•°")
                        return fv / 100.0
                    try:
                        min_v = parse_pct_str(parts[0])
                        max_v = parse_pct_str(parts[1])
                    except ValueError as e:
                        await update.message.reply_text(f"âŒ æ ¼å¼é”™è¯¯: {e}", parse_mode="HTML")
                        return
                else:
                    # æ™®é€šæ•°å€¼è§£æ
                    try:
                        min_v = None if parts[0].lower() in ("null", "none", "æ— ", "ç©º", "æ¸…ç©º", "") else float(parts[0])
                    except ValueError:
                        await update.message.reply_text(f"âŒ æœ€å°å€¼æ ¼å¼é”™è¯¯ï¼š<code>{parts[0]}</code>", parse_mode="HTML")
                        return
                    try:
                        max_v = None if parts[1].lower() in ("null", "none", "æ— ", "ç©º", "æ¸…ç©º", "") else float(parts[1])
                    except ValueError:
                        await update.message.reply_text(f"âŒ æœ€å¤§å€¼æ ¼å¼é”™è¯¯ï¼š<code>{parts[1]}</code>", parse_mode="HTML")
                        return
                    if filter_key in ("sol_sniffer_score", "token_sniffer_score"):
                        for label, val in (("æœ€å°å€¼", min_v), ("æœ€å¤§å€¼", max_v)):
                            if val is not None and (val < 0 or val > 100):
                                await update.message.reply_text(f"âŒ {label}éœ€åœ¨ 0-100 ä¹‹é—´", parse_mode="HTML")
                                return
                
                await self.state.set_filter(filter_key, min_v, max_v)
                
                filter_names = {
                    "market_cap_usd": "å¸‚å€¼(USD)", "liquidity_usd": "æ± å­(USD)",
                    "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)", "top10_ratio": "å‰åå æ¯”",
                    "holder_count": "æŒæœ‰äººæ•°", "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯”",
                    "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
                    "sol_sniffer_score": "SolSnifferè¯„åˆ†",
                    "token_sniffer_score": "TokenSnifferè¯„åˆ†",
                }
                display_name = filter_names.get(filter_key, filter_key)
                display_name_escaped = html.escape(str(display_name))
                
                # æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
                if filter_key in ["top10_ratio", "max_holder_ratio"]:
                    min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— é™åˆ¶"
                else:
                    min_str = f"{min_v:,.0f}" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v:,.0f}" if max_v is not None else "æ— é™åˆ¶"
                
                # æ¸…é™¤ç­‰å¾…çŠ¶æ€
                context.user_data[f'{user_id}_waiting'] = None
                
                # å¦‚æœæœ‰ä¿å­˜çš„èœå•queryï¼Œè¿”å›èœå•é¡µé¢
                saved_query = context.user_data.get(f'{user_id}_filter_menu_query')
                if saved_query:
                    # æ›´æ–°èœå•æ˜¾ç¤º
                    await self.show_filter_menu(saved_query, edit=True)
                    context.user_data[f'{user_id}_filter_menu_query'] = None
                    await update.message.reply_text(
                        f"âœ… <b>{display_name_escaped}</b> å·²æ›´æ–°ï¼š{min_str} ~ {max_str}\n\n"
                        f"ğŸ’¡ å·²è‡ªåŠ¨è¿”å›èœå•ï¼Œå¯ç»§ç»­è®¾ç½®å…¶ä»–æ¡ä»¶",
                        parse_mode="HTML"
                    )
                else:
                    await update.message.reply_text(
                        f"âœ… ç­›é€‰æ¡ä»¶å·²æ›´æ–°\n\n<b>{display_name_escaped}</b>\næœ€å°å€¼: {min_str}\næœ€å¤§å€¼: {max_str}",
                        parse_mode="HTML"
                    )
            elif waiting == 'add_client':
                # æ£€æŸ¥æ˜¯å¦è¾“å…¥"å®Œæˆ"
                if text.strip().lower() in ('å®Œæˆ', 'done', 'finish'):
                    count = context.user_data.get(f'{user_id}_client_count', 0)
                    context.user_data[f'{user_id}_waiting'] = None
                    context.user_data[f'{user_id}_client_count'] = 0
                    await update.message.reply_text(f"âœ… æ‰¹é‡æ·»åŠ å®Œæˆï¼å…±æ·»åŠ  {count} ä¸ªå®¢æˆ·ç«¯")
                    return
                
                # æ”¯æŒï¼š
                # 1) "name session"ï¼ˆè‡ªå®šä¹‰åç§°ï¼‰
                # 2) çº¯ session å­—ç¬¦ä¸²ï¼ˆè‡ªåŠ¨ä½¿ç”¨è¯¥è´¦å· username ä½œä¸ºåç§°ï¼‰
                raw = text.strip()
                parts = raw.split(maxsplit=1)
                name = parts[0] if len(parts) == 2 else None
                session = parts[1] if len(parts) == 2 else raw
                if not self.scheduler or not self.scheduler.client_pool:
                    await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦/å®¢æˆ·ç«¯æ± ")
                    return
                try:
                    final_name = await self.scheduler.client_pool.add_client(name, session)
                    count = context.user_data.get(f'{user_id}_client_count', 0) + 1
                    context.user_data[f'{user_id}_client_count'] = count

                    # ä¸ºæ–°æ·»åŠ çš„ MTProto å®¢æˆ·ç«¯æ³¨å†Œæ¶ˆæ¯ç›‘å¬ï¼ˆç”¨äºç›‘å¬ç¾¤å†…å…¶ä»–æœºå™¨äºº/ç”¨æˆ·æ¶ˆæ¯ï¼‰
                    client = self.scheduler.client_pool.get_client(final_name)
                    if client:
                        @client.on(events.NewMessage)
                        async def _mt_on_message(event):
                            try:
                                chat = await event.get_chat()
                                chat_id = getattr(chat, "id", None)
                                if chat_id is None:
                                    return
                                text_mt = event.raw_text or ""
                                if not text_mt:
                                    return

                                snap_mt = await self.state.snapshot()
                                tasks_mt = snap_mt.get("tasks", {})
                                if not tasks_mt:
                                    return

                                username = getattr(chat, "username", None)
                                name_keys = []
                                if username:
                                    name_keys.append(f"@{username}")

                                matched_tasks: List[str] = []
                                for tid, cfg in tasks_mt.items():
                                    if not cfg.get("enabled"):
                                        continue
                                    listens = cfg.get("listen_chats", [])
                                    if chat_id in listens or any(k in listens for k in name_keys):
                                        matched_tasks.append(tid)

                                if not matched_tasks:
                                    return

                                logger.info(f"ğŸ“¨ [MTProto] Message received from chat {chat_id} for tasks: {matched_tasks}")
                                found_mt = set(CA_PATTERN.findall(text_mt))
                                if not found_mt:
                                    return
                                logger.info(f"ğŸ” [MTProto] Found {len(found_mt)} CA(s) in message: {[ca[:8] + '...' for ca in found_mt]}")

                                for ca_mt in found_mt:
                                    for tid in matched_tasks:
                                        asyncio.create_task(self._process_ca_bg(chain_hint(ca_mt), ca_mt, task_id=tid))
                            except Exception as e:
                                logger.error(f"âŒ MTProto listener error (new client): {e}", exc_info=True)

                    await update.message.reply_text(
                        f"âœ… å®¢æˆ·ç«¯å·²æ·»åŠ ï¼š{final_name}ï¼ˆç¬¬ {count} ä¸ªï¼‰\nç»§ç»­ä¸Šä¼ æ–‡ä»¶æˆ–å‘é€å­—ç¬¦ä¸²ï¼Œå®Œæˆåè¾“å…¥ã€Œå®Œæˆã€"
                    )
                except Exception as e:
                    await update.message.reply_text(f"âŒ æ·»åŠ å¤±è´¥: {e}")
            elif waiting == 'add_task':
                name = text.strip()
                if not name:
                    await update.message.reply_text("âŒ ä»»åŠ¡åç§°ä¸èƒ½ä¸ºç©º")
                    return
                created = await self.state.create_task(name)
                if not created:
                    await update.message.reply_text("âŒ ä»»åŠ¡å·²å­˜åœ¨ï¼Œè¯·æ¢ä¸€ä¸ªåç§°")
                    return
                await self.state.set_current_task(name)
                count = context.user_data.get(f'{user_id}_task_count', 0) + 1
                context.user_data[f'{user_id}_task_count'] = count
                await update.message.reply_text(
                    f"âœ… å·²åˆ›å»ºä»»åŠ¡å¹¶åˆ‡æ¢ä¸ºå½“å‰ï¼š{name}\n"
                    f"ï¼ˆé»˜è®¤æš‚åœï¼Œè¯·åœ¨ä»»åŠ¡åˆ—è¡¨å¯ç”¨ï¼›ç»§ç»­é…ç½®ç›‘å¬ç¾¤ã€æ¨é€ç›®æ ‡ã€ç­›é€‰æ¡ä»¶ï¼‰\n"
                    f"å·²åˆ›å»ºæ•°é‡ï¼š{count}",
                    parse_mode="HTML"
                )
            elif waiting.startswith('set_window:'):
                task_id = waiting.split(':', 1)[1]
                parts = text.strip().split()
                if len(parts) != 2:
                    await update.message.reply_text("âŒ è¯·è¾“å…¥ä¸¤ä¸ªå€¼ï¼š<code>HH:MM HH:MM</code>ï¼Œæˆ–ç”¨ <code>none</code> ä»£è¡¨ä¸é™åˆ¶ã€‚", parse_mode="HTML")
                    # è¿”å›ä»»åŠ¡åˆ—è¡¨ç•Œé¢ï¼Œæ¸…ç†ç­‰å¾…çŠ¶æ€
                    saved_query = context.user_data.get(f'{user_id}_window_menu_query')
                    if saved_query:
                        await self.list_tasks_callback(saved_query)
                    else:
                        await self.show_task_menu(update.message)
                    context.user_data[f'{user_id}_waiting'] = None
                    context.user_data[f'{user_id}_window_menu_query'] = None
                    return
                start_raw, end_raw = parts
                def norm(val):
                    # æ”¯æŒå¤šç§æ¸…ç©ºæ–¹å¼ï¼šnone, None, null, Null, æ— , ç©º, æ¸…ç©º
                    val_lower = val.lower().strip()
                    if val_lower in ("none", "null", "æ— ", "ç©º", "æ¸…ç©º", ""):
                        return None
                    if len(val) == 5 and val[2] == ":" and val[:2].isdigit() and val[3:].isdigit():
                        h = int(val[:2]); m = int(val[3:])
                        if 0 <= h < 24 and 0 <= m < 60:
                            return f"{h:02d}:{m:02d}"
                    return "invalid"
                start_v = norm(start_raw)
                end_v = norm(end_raw)
                if start_v == "invalid" or end_v == "invalid":
                    await update.message.reply_text("âŒ æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·è¾“å…¥ <code>HH:MM HH:MM</code>ï¼Œæˆ–ç”¨ <code>none</code> ä»£è¡¨ä¸é™åˆ¶ã€‚", parse_mode="HTML")
                    # è¾“å…¥é”™è¯¯ï¼Œè¿”å›ä»»åŠ¡åˆ—è¡¨ç•Œé¢
                    saved_query = context.user_data.get(f'{user_id}_window_menu_query')
                    if saved_query:
                        await self.list_tasks_callback(saved_query)
                    else:
                        await self.show_task_menu(update.message)
                    context.user_data[f'{user_id}_waiting'] = None
                    context.user_data[f'{user_id}_window_menu_query'] = None
                    return
                # æˆåŠŸè§£æï¼Œä¿å­˜æ—¶é—´çª—å¹¶åˆ·æ–°ä»»åŠ¡åˆ—è¡¨
                await self.state.set_task_window(task_id, start_v, end_v)
                if self.scheduler:
                    for t in self.scheduler.tasks:
                        if t.get("id") == task_id:
                            t["start_time"] = start_v
                            t["end_time"] = end_v
                            # ç«‹å³æ ¹æ®æ–°çš„æ—¶é—´çª—æ›´æ–°ä»»åŠ¡çš„å¯ç”¨çŠ¶æ€ä¸ next_runï¼Œä¿è¯è‡ªåŠ¨å¯åœç”Ÿæ•ˆ
                            try:
                                in_window = self._is_in_time_window(start_v, end_v)
                            except Exception:
                                in_window = True
                            if in_window:
                                t["enabled"] = True
                                t["next_run"] = time.time()
                            else:
                                t["enabled"] = False
                                # å°† next_run è®¾ç½®ä¸ºä¸‹ä¸€ä¸ªæ—¶é—´çª—å¼€å§‹æ—¶åˆ»ï¼ˆä¸­å›½æ—¶åŒºï¼‰
                                try:
                                    if start_v:
                                        h, m = start_v.split(":")
                                        sh = int(h); sm = int(m)
                                        from datetime import datetime as _dt, timedelta as _td
                                        now_dt = _dt.now(TZ_SHANGHAI)
                                        candidate = now_dt.replace(hour=sh, minute=sm, second=0, microsecond=0)
                                        if candidate <= now_dt:
                                            candidate = candidate + _td(days=1)
                                        t["next_run"] = candidate.timestamp()
                                    else:
                                        t["next_run"] = time.time()
                                except Exception:
                                    t["next_run"] = time.time()
                    self.scheduler.client_pool.update_tasks_config(self.scheduler.tasks)
                start_str = start_v or "ä¸é™åˆ¶"
                end_str = end_v or "ä¸é™åˆ¶"
                await update.message.reply_text(f"âœ… å·²æ›´æ–°ä»»åŠ¡æ—¶é—´çª—ï¼š{start_str} ~ {end_str}", parse_mode="HTML")
                saved_query = context.user_data.get(f'{user_id}_window_menu_query')
                if saved_query:
                    await self.list_tasks_callback(saved_query)
                else:
                    await self.show_task_menu(update.message)
                context.user_data[f'{user_id}_waiting'] = None
                context.user_data[f'{user_id}_window_menu_query'] = None
            # æ¸…é™¤ç­‰å¾…çŠ¶æ€
            context.user_data[f'{user_id}_waiting'] = None
        except ValueError:
            await update.message.reply_text("âŒ è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œè¯·é‡è¯•")
        except Exception as e:
            await update.message.reply_text(f"âŒ è®¾ç½®å¤±è´¥: {e}")
    
    async def _extract_chat_id_from_link(self, link: str):
        """ä»Telegramé‚€è¯·é“¾æ¥ä¸­æå–chat_idæˆ–usernameï¼ˆæ”¯æŒç¾¤ç»„/æœºå™¨äºº/ä¸ªäººï¼‰"""
        import re
        try:
            link_clean = link.strip()
            
            # å¦‚æœç›´æ¥æ˜¯æ•°å­—IDï¼ˆå¯èƒ½æ˜¯è´Ÿæ•°ï¼Œè¡¨ç¤ºç¾¤ç»„ï¼‰
            if link_clean.lstrip('-').isdigit():
                return int(link_clean)
            
            # å¦‚æœç›´æ¥æ˜¯@usernameæ ¼å¼ï¼Œè¿”å›å­—ç¬¦ä¸²
            if link_clean.startswith('@'):
                return link_clean
            
            # å¤„ç†ç§æœ‰ç¾¤é‚€è¯·é“¾æ¥: https://t.me/joinchat/... æˆ– https://t.me/+...
            if 'joinchat' in link_clean or link_clean.startswith("https://t.me/+") or link_clean.startswith("t.me/+"):
                try:
                    chat = await self.app.bot.join_chat(link_clean)
                    return chat.id
                except Exception as e:
                    logger.warning(f"Failed to join chat from link {link}: {e}")
                    return None
            
            # å¤„ç†å…¬å…±ç¾¤/æœºå™¨äººé“¾æ¥: https://t.me/groupname æˆ– @groupname
            match = re.search(r'(?:t\.me/|@)([a-zA-Z0-9_]+)', link)
            if match:
                username = match.group(1)
                try:
                    # å°è¯•è·å–chatä¿¡æ¯ï¼Œå¦‚æœæˆåŠŸè¿”å›IDï¼Œå¦åˆ™è¿”å›@usernameå­—ç¬¦ä¸²
                    chat = await self.app.bot.get_chat(f"@{username}")
                    return chat.id
                except Exception as e:
                    # å¦‚æœè·å–å¤±è´¥ï¼Œå¯èƒ½æ˜¯æœºå™¨äººæˆ–æ— æ•ˆç”¨æˆ·åï¼Œè¿”å›@usernameå­—ç¬¦ä¸²
                    logger.debug(f"Failed to get chat from username {username}: {e}, returning @username")
                    return f"@{username}"
            
            return None
        except Exception as e:
            logger.warning(f"Failed to extract chat_id from link {link}: {e}")
            return None

    async def on_document(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†æ–‡æ¡£æ¶ˆæ¯ï¼ˆç”¨äºæ¥æ”¶ .session æ–‡ä»¶ï¼‰"""
        if not update.message or not update.effective_user:
            return
        user_id = update.effective_user.id
        chat_id = update.effective_chat.id if update.effective_chat else None
        if user_id not in self.admin_ids or chat_id != user_id:
            # ä»…åœ¨ç®¡ç†å‘˜ç§èŠä¸­å¤„ç†
            return
        if not hasattr(context, 'user_data'):
            context.user_data = {}
        waiting = context.user_data.get(f'{user_id}_waiting', '')
        if waiting != 'add_client':
            return

        if not self.scheduler or not self.scheduler.client_pool:
            await update.message.reply_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦/å®¢æˆ·ç«¯æ± ")
            return

        doc = update.message.document
        if not doc:
            return
        try:
            # ä¿å­˜åˆ°æœ¬åœ° sessions ç›®å½•
            sessions_dir = Path("sessions")
            sessions_dir.mkdir(parents=True, exist_ok=True)
            filename = doc.file_name or f"{doc.file_unique_id}.session"
            dest = sessions_dir / filename
            tg_file = await doc.get_file()
            await tg_file.download_to_drive(custom_path=str(dest))

            final_name = await self.scheduler.client_pool.add_client(None, str(dest))
            count = context.user_data.get(f'{user_id}_client_count', 0) + 1
            context.user_data[f'{user_id}_client_count'] = count
            await update.message.reply_text(
                f"âœ… å·²ä»æ–‡ä»¶æ·»åŠ å®¢æˆ·ç«¯ï¼š{final_name}ï¼ˆç¬¬ {count} ä¸ªï¼‰\nè·¯å¾„ï¼š`{dest}`\nç»§ç»­ä¸Šä¼ æ–‡ä»¶æˆ–å‘é€å­—ç¬¦ä¸²ï¼Œå®Œæˆåè¾“å…¥ã€Œå®Œæˆã€",
                parse_mode="Markdown",
            )
        except Exception as e:
            logger.warning(f"Failed to handle session document: {e}")
            await update.message.reply_text(f"âŒ å¤„ç† session æ–‡ä»¶å¤±è´¥: {e}")
    
    async def _get_chat_info(self, chat_id) -> Optional[dict]:
        """è·å–èŠå¤©ä¿¡æ¯ï¼ˆæ”¯æŒç¾¤ç»„/æœºå™¨äºº/ä¸ªäººï¼‰"""
        try:
            # æ”¯æŒå­—ç¬¦ä¸²ï¼ˆ@usernameï¼‰æˆ–æ•´æ•°ï¼ˆchat_idï¼‰
            chat = await self.app.bot.get_chat(chat_id)
            chat_type = chat.type
            title = None
            username = None
            
            if chat_type == "private":
                title = f"{chat.first_name or ''} {chat.last_name or ''}".strip() or chat.username or f"ç”¨æˆ· {chat.id}"
                username = chat.username
            elif chat_type in ("group", "supergroup"):
                title = chat.title
                username = chat.username
            elif chat_type == "channel":
                title = chat.title
                username = chat.username
            elif chat_type == "bot":
                title = chat.first_name or chat.username or f"æœºå™¨äºº {chat.id}"
                username = chat.username
            else:
                title = getattr(chat, 'title', None) or getattr(chat, 'first_name', None) or f"ç›®æ ‡ {chat.id}"
                username = getattr(chat, 'username', None)
            
            return {
                'title': title,
                'username': username,
                'type': chat_type,
                'id': chat.id
            }
        except Exception as e:
            logger.debug(f"Failed to get chat info for {chat_id}: {e}")
            return None
    
    async def list_listen_callback(self, query):
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        tasks = snap.get("tasks", {})
        if not current:
            await query.edit_message_text("âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œå†é…ç½®ç›‘å¬ç¾¤ç»„ã€‚", parse_mode="HTML")
            return
        listen_chats = tasks.get(current, {}).get("listen_chats", [])
        if not listen_chats:
            await query.edit_message_text(f"ğŸ“‹ <b>ç›‘å¬ç¾¤ç»„åˆ—è¡¨</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n\næš‚æ— ç›‘å¬ç¾¤ç»„", parse_mode="HTML")
            return
        
        keyboard = []
        text = f"ğŸ“‹ <b>ç›‘å¬ç¾¤ç»„åˆ—è¡¨</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰ ({len(listen_chats)}ä¸ª)\n\n"
        for idx, chat_id in enumerate(listen_chats, 1):
            chat_info = await self._get_chat_info(chat_id)
            chat_name = html.escape(chat_info.get('title', f'ç¾¤ç»„ {chat_id}') if chat_info else f'ç¾¤ç»„ {chat_id}')
            text += f"{idx}. <b>{chat_name}</b>\n   ID: <code>{chat_id}</code>\n\n"
            keyboard.append([InlineKeyboardButton(f"âŒ åˆ é™¤ {chat_name}", callback_data=f"del_listen_{chat_id}")])
        
        keyboard.append([InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_listen")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)
    
    async def list_push_callback(self, query):
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        tasks = snap.get("tasks", {})
        if not current:
            await query.edit_message_text("âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œå†é…ç½®æ¨é€ç›®æ ‡ã€‚", parse_mode="HTML")
            return
        push_chats = tasks.get(current, {}).get("push_chats", [])
        if not push_chats:
            await query.edit_message_text(f"ğŸ“‹ <b>æ¨é€ç›®æ ‡åˆ—è¡¨</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n\næš‚æ— æ¨é€ç›®æ ‡", parse_mode="HTML")
            return
        
        keyboard = []
        text = f"ğŸ“‹ <b>æ¨é€ç›®æ ‡åˆ—è¡¨</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰ ({len(push_chats)}ä¸ª)\n\n"
        for idx, chat_id in enumerate(push_chats, 1):
            chat_info = await self._get_chat_info(chat_id)
            if chat_info:
                chat_name = html.escape(chat_info.get('title', f'ç›®æ ‡ {chat_id}'))
                chat_type = chat_info.get('type', 'unknown')
                username = chat_info.get('username')
                chat_id_display = chat_info.get('id', chat_id)
                
                type_icon = {
                    'group': 'ğŸ‘¥',
                    'supergroup': 'ğŸ‘¥',
                    'channel': 'ğŸ“¢',
                    'private': 'ğŸ‘¤',
                    'bot': 'ğŸ¤–'
                }.get(chat_type, 'ğŸ“Œ')
                
                type_name = {
                    'group': 'ç¾¤ç»„',
                    'supergroup': 'ç¾¤ç»„',
                    'channel': 'é¢‘é“',
                    'private': 'ä¸ªäºº',
                    'bot': 'æœºå™¨äºº'
                }.get(chat_type, 'ç›®æ ‡')
                
                username_str = f" @{html.escape(username)}" if username else ""
                text += f"{idx}. {type_icon} <b>{chat_name}</b> ({type_name})\n   ID: <code>{chat_id_display}</code>{username_str}\n\n"
            else:
                chat_id_escaped = html.escape(str(chat_id))
                text += f"{idx}. ğŸ“Œ <b>ç›®æ ‡</b>\n   ID/ç”¨æˆ·å: <code>{chat_id_escaped}</code>\n\n"
            keyboard.append([InlineKeyboardButton(f"âŒ åˆ é™¤", callback_data=f"del_push_{chat_id}")])
        
        keyboard.append([InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_push")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)
    
    async def show_task_list_message(self, message):
        """æ˜¾ç¤ºä»»åŠ¡åˆ—è¡¨ï¼ˆç”¨äºé”®ç›˜èœå•ï¼‰"""
        text, reply_markup = await self._build_task_list_message()
        await message.reply_text(text, parse_mode="HTML", reply_markup=reply_markup)

    async def list_tasks_callback(self, query):
        """æ˜¾ç¤ºä»»åŠ¡åˆ—è¡¨ï¼ˆç”¨äºå†…è”æŒ‰é’®ï¼‰"""
        text, reply_markup = await self._build_task_list_message()
        await query.edit_message_text(text, parse_mode="HTML", reply_markup=reply_markup)

    async def _build_task_list_message(self) -> Tuple[str, InlineKeyboardMarkup]:
        snap = await self.state.snapshot()
        tasks = snap.get("tasks", {})
        current = snap.get("current_task")
        keyboard = []
        lines = []
        if not tasks:
            lines.append("ğŸ“‹ <b>ä»»åŠ¡åˆ—è¡¨</b>\n\næš‚æ— ä»»åŠ¡")
        else:
            lines.append(f"ğŸ“‹ <b>ä»»åŠ¡åˆ—è¡¨</b> ({len(tasks)}ä¸ª)\n")
            scheduler_tasks = {}
            if self.scheduler:
                for st in self.scheduler.list_tasks():
                    scheduler_tasks[st.get("id")] = st

            for tid, cfg in tasks.items():
                actual_enabled = cfg.get("enabled")
                if tid in scheduler_tasks:
                    st = scheduler_tasks[tid]
                    actual_enabled = st.get("enabled", actual_enabled)
                    if actual_enabled != cfg.get("enabled"):
                        await self.state.set_task_enabled(tid, actual_enabled)

                start_time = cfg.get("start_time")
                end_time = cfg.get("end_time")
                has_window = start_time or end_time
                if has_window:
                    in_window = self._is_in_time_window(start_time, end_time)
                    if not in_window:
                        actual_enabled = False

                status = "âœ… å¯ç”¨" if actual_enabled else "â¸ï¸ æš‚åœ"
                tag = "ï¼ˆå½“å‰ï¼‰" if tid == current else ""
                listen_count = len(cfg.get("listen_chats", []))
                push_count = len(cfg.get("push_chats", []))
                interval_minutes = None
                next_run_time = None
                if tid in scheduler_tasks:
                    st = scheduler_tasks[tid]
                    interval_minutes = st.get("interval_minutes")
                    next_run_ts = st.get("next_run")
                    if next_run_ts:
                        from datetime import datetime, timezone, timedelta
                        tz_shanghai = timezone(timedelta(hours=8))
                        next_run_dt = datetime.fromtimestamp(next_run_ts, tz=tz_shanghai)
                        next_run_time = next_run_dt.strftime('%m-%d %H:%M')

                lines.append(f"â€¢ <b>{html.escape(tid)}</b> {tag} | {status}")
                interval_str = f" | â° æ¯{interval_minutes}åˆ†é’Ÿ" if interval_minutes else ""
                next_run_str = f" | ä¸‹æ¬¡: {next_run_time}" if next_run_time else ""
                window_str = ""
                if start_time or end_time:
                    window_str = f" | æ—¶é—´çª—: {start_time or '--:--'} ~ {end_time or '--:--'}"
                lines.append(f"  ç›‘å¬: {listen_count} | æ¨é€: {push_count}{interval_str}{next_run_str}{window_str}")

                btn_row = []
                if tid == current:
                    btn_row.append(InlineKeyboardButton("âœ… å½“å‰", callback_data="noop"))
                else:
                    btn_row.append(InlineKeyboardButton(f"åˆ‡æ¢ {tid}", callback_data=f"task_select:{tid}"))

                can_manual_toggle = True
                if has_window:
                    in_window = self._is_in_time_window(start_time, end_time)
                    can_manual_toggle = in_window

                if actual_enabled:
                    if can_manual_toggle:
                        btn_row.append(InlineKeyboardButton("â¸ï¸ æš‚åœ", callback_data=f"task_disable:{tid}"))
                    else:
                        btn_row.append(InlineKeyboardButton("â¸ï¸ æš‚åœ", callback_data="noop"))
                else:
                    if can_manual_toggle:
                        btn_row.append(InlineKeyboardButton("â–¶ï¸ å¯ç”¨", callback_data=f"task_enable:{tid}"))
                    else:
                        btn_row.append(InlineKeyboardButton("â–¶ï¸ å¯ç”¨", callback_data="noop"))

                btn_row.append(InlineKeyboardButton("â° æ—¶é—´çª—", callback_data=f"task_window:{tid}"))
                btn_row.append(InlineKeyboardButton("ğŸ—‘ï¸ åˆ é™¤", callback_data=f"task_delete:{tid}"))
                keyboard.append(btn_row)
                lines.append("")

        keyboard.append([InlineKeyboardButton("â¬…ï¸ è¿”å›", callback_data="back_task_menu")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        return "\n".join(lines), reply_markup

    async def list_clients_callback(self, query):
        if not self.scheduler or not self.scheduler.client_pool:
            await query.edit_message_text("âš ï¸ æœªå¯ç”¨ä»»åŠ¡è°ƒåº¦/å®¢æˆ·ç«¯æ± ")
            return
        items = self.scheduler.client_pool.describe_clients()
        if not items:
            await query.edit_message_text("ğŸ‘¤ <b>å®¢æˆ·ç«¯åˆ—è¡¨</b>\n\næš‚æ— å®¢æˆ·ç«¯", parse_mode="HTML")
            return
        lines = ["ğŸ‘¤ <b>å®¢æˆ·ç«¯åˆ—è¡¨</b>\n"]
        keyboard = []
        for c in items:
            display_name = c.get('name')
            internal_name = c.get('internal_name') or display_name
            username = c.get('username')
            show_name = f"@{username}" if username else display_name
            lines.append(f"â€¢ <b>{show_name}</b> | api_id=<code>{c.get('api_id')}</code>")
            lines.append(f"  session: <code>{c.get('session_type')}</code> (<code>{c.get('session_preview')}</code>)")
            lines.append(f"  çŠ¶æ€: {c.get('status')}\n")
            keyboard.append([InlineKeyboardButton(f"âŒ åˆ é™¤ {show_name}", callback_data=f"del_client_{internal_name}")])
        keyboard.append([InlineKeyboardButton("â¬…ï¸ è¿”å›", callback_data="back_task_menu")])
        await query.edit_message_text("\n".join(lines), parse_mode="HTML", reply_markup=InlineKeyboardMarkup(keyboard))
    
    async def list_filters_callback(self, query):
        snap = await self.state.snapshot()
        current = snap.get("current_task")
        if not current:
            await query.edit_message_text("âš ï¸ è¯·å…ˆåˆ›å»ºå¹¶é€‰æ‹©ä»»åŠ¡ï¼Œå†é…ç½®ç­›é€‰æ¡ä»¶ã€‚", parse_mode="HTML")
            return
        filters_cfg = snap.get("tasks", {}).get(current, {}).get("filters", {})
        text = f"ğŸ” <b>ç­›é€‰æ¡ä»¶</b>ï¼ˆå½“å‰ä»»åŠ¡ï¼š{html.escape(current)}ï¼‰\n" + self._format_filters(filters_cfg)
        await query.edit_message_text(text, parse_mode="HTML")
    
    async def _format_settings(self, snap):
        """æ ¼å¼åŒ–é…ç½®ä¿¡æ¯"""
        text = "âš™ï¸ <b>å½“å‰é…ç½®</b>\n\n"
        
        listen_chats = snap.get("listen_chats", [])
        text += f"ğŸ‘¥ <b>ç›‘å¬ç¾¤ç»„</b> ({len(listen_chats)}ä¸ª)\n"
        if listen_chats:
            for chat_id in listen_chats:
                chat_info = await self._get_chat_info(chat_id)
                chat_name = chat_info.get('title', f'ç¾¤ç»„ {chat_id}') if chat_info else f'ç¾¤ç»„ {chat_id}'
                chat_name_escaped = html.escape(str(chat_name))
                chat_id_escaped = html.escape(str(chat_id))
                text += f"â€¢ <b>{chat_name_escaped}</b> (<code>{chat_id_escaped}</code>)\n"
        else:
            text += "â€¢ æš‚æ— \n"
        text += "\n"
        
        push_chats = snap.get("push_chats", [])
        text += f"ğŸ“¤ <b>æ¨é€ç›®æ ‡</b> ({len(push_chats)}ä¸ª)\n"
        if push_chats:
            for chat_id in push_chats:
                chat_info = await self._get_chat_info(chat_id)
                if chat_info:
                    chat_name = chat_info.get('title', f'ç›®æ ‡ {chat_id}')
                    chat_type = chat_info.get('type', 'unknown')
                    username = chat_info.get('username')
                    chat_id_display = chat_info.get('id', chat_id)
                    
                    # ç±»å‹å›¾æ ‡å’Œåç§°
                    type_info = {
                        'group': ('ğŸ‘¥', 'ç¾¤ç»„'),
                        'supergroup': ('ğŸ‘¥', 'ç¾¤ç»„'),
                        'channel': ('ğŸ“¢', 'é¢‘é“'),
                        'private': ('ğŸ‘¤', 'ä¸ªäºº'),
                        'bot': ('ğŸ¤–', 'æœºå™¨äºº')
                    }.get(chat_type, ('ğŸ“Œ', 'ç›®æ ‡'))
                    
                    type_icon, type_name = type_info
                    chat_name_escaped = html.escape(str(chat_name))
                    chat_id_escaped = html.escape(str(chat_id_display))
                    username_str = f" @{html.escape(str(username))}" if username else ""
                    text += f"â€¢ {type_icon} <b>{chat_name_escaped}</b> ({type_name}) <code>{chat_id_escaped}</code>{username_str}\n"
                else:
                    chat_id_escaped = html.escape(str(chat_id))
                    text += f"â€¢ ğŸ“Œ <b>ç›®æ ‡</b> (<code>{chat_id_escaped}</code>)\n"
        else:
            text += "â€¢ æš‚æ— \n"
        text += "\n"
        
        text += "ğŸ” <b>ç­›é€‰æ¡ä»¶</b>\n"
        filters_cfg = snap.get("filters", {})
        text += self._format_filters(filters_cfg)
        text += "\n"
        
        return text

    async def _process_ca_bg(self, chain: str, ca: str, task_id: Optional[str] = None):
        """åå°å¤„ç† CAï¼Œæ·»åŠ è¶…æ—¶ä¸å¼‚å¸¸ä¿æŠ¤ï¼Œé¿å…é˜»å¡ä¸»æµç¨‹"""
        try:
            await asyncio.wait_for(
                self.process_ca(chain, ca, False, task_id=task_id),
                timeout=120.0  # 2åˆ†é’Ÿè¶…æ—¶ï¼Œé˜²æ­¢é•¿æœŸé˜»å¡
            )
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸  Timeout processing CA {ca[:8]}... (exceeded 120s)")
        except Exception as e:
            logger.error(f"âŒ Error processing CA {ca[:8]}...: {e}", exc_info=True)
    
    def _is_in_time_window(self, start_time: Optional[str], end_time: Optional[str]) -> bool:
        """æ£€æŸ¥å½“å‰æ—¶é—´æ˜¯å¦åœ¨æ—¶é—´çª—å†…ï¼ˆä¸ task_scheduler.py ä¸­çš„é€»è¾‘ä¸€è‡´ï¼‰"""
        if not start_time and not end_time:
            return True  # æ²¡æœ‰è®¾ç½®æ—¶é—´çª—ï¼Œå§‹ç»ˆå…è®¸
        
        now_dt = datetime.now(TZ_SHANGHAI)
        now_minutes = now_dt.hour * 60 + now_dt.minute
        start_minutes = None
        end_minutes = None
        
        try:
            if start_time:
                h, m = start_time.split(":")
                start_minutes = int(h) * 60 + int(m)
            if end_time:
                h, m = end_time.split(":")
                end_minutes = int(h) * 60 + int(m)
        except Exception:
            logger.warning(f"âš ï¸ Invalid start/end time format: {start_time} - {end_time}")
            return True  # æ ¼å¼é”™è¯¯æ—¶å…è®¸è¿è¡Œï¼Œé¿å…é˜»å¡
        
        # åˆ¤æ–­æ˜¯å¦åœ¨æ—¶é—´çª—å†…ï¼ˆæ”¯æŒè·¨å¤©ï¼‰
        if start_minutes is not None and end_minutes is not None:
            if start_minutes <= end_minutes:
                return start_minutes <= now_minutes <= end_minutes
            else:
                return now_minutes >= start_minutes or now_minutes <= end_minutes
        elif start_minutes is not None:
            return now_minutes >= start_minutes
        elif end_minutes is not None:
            return now_minutes <= end_minutes
        else:
            return True

    def _format_filters(self, filters_cfg):
        """æ ¼å¼åŒ–ç­›é€‰æ¡ä»¶"""
        filter_names = {
            "market_cap_usd": "å¸‚å€¼(USD)",
            "liquidity_usd": "æ± å­(USD)",
            "open_minutes": "å¼€ç›˜æ—¶é—´(åˆ†é’Ÿ)",
            "top10_ratio": "å‰åå æ¯”",
            "holder_count": "æŒæœ‰äººæ•°",
            "max_holder_ratio": "æœ€å¤§æŒä»“å æ¯”",
            "trades_5m": "5åˆ†é’Ÿäº¤æ˜“æ•°",
            "sol_sniffer_score": "SolSnifferè¯„åˆ†",
            "token_sniffer_score": "TokenSnifferè¯„åˆ†",
        }
        text = ""
        for key, display_name in filter_names.items():
            f = filters_cfg.get(key, {})
            min_v = f.get("min")
            max_v = f.get("max")
            if min_v is None and max_v is None:
                text += f"â€¢ {display_name}: æœªè®¾ç½®\n"
            else:
                if key in ["top10_ratio", "max_holder_ratio"]:
                    min_str = f"{min_v*100:.1f}%" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v*100:.1f}%" if max_v is not None else "æ— é™åˆ¶"
                else:
                    min_str = f"{min_v:,.0f}" if min_v is not None else "æ— é™åˆ¶"
                    max_str = f"{max_v:,.0f}" if max_v is not None else "æ— é™åˆ¶"
                text += f"â€¢ {display_name}: {min_str} ~ {max_str}\n"
        return text

    async def _setup_commands(self):
        """Setup bot commands menu."""
        # All commands that will appear in the menu
        commands = [
            BotCommand("start", "å¯åŠ¨æœºå™¨äºº"),
            BotCommand("menu", "æŸ¥çœ‹å‘½ä»¤èœå•"),
            BotCommand("c", "æŸ¥è¯¢åˆçº¦åœ°å€"),
            BotCommand("settings", "æŸ¥çœ‹å½“å‰é…ç½®"),
            BotCommand("add_client", "æ·»åŠ MTProtoå®¢æˆ·ç«¯ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("add_task", "æ·»åŠ ä»»åŠ¡ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("tasks", "æŸ¥çœ‹ä»»åŠ¡åˆ—è¡¨ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("task_pause", "æš‚åœä»»åŠ¡ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("task_resume", "æ¢å¤ä»»åŠ¡ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("add_listen", "æ·»åŠ ç›‘å¬ç¾¤ç»„ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("del_listen", "åˆ é™¤ç›‘å¬ç¾¤ç»„ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("list_listen", "æŸ¥çœ‹ç›‘å¬ç¾¤ç»„åˆ—è¡¨ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("add_push", "æ·»åŠ æ¨é€ç¾¤ç»„ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("del_push", "åˆ é™¤æ¨é€ç¾¤ç»„ï¼ˆç®¡ç†å‘˜ï¼‰"),
            BotCommand("list_push", "æŸ¥çœ‹æ¨é€ç¾¤ç»„åˆ—è¡¨ï¼ˆç®¡ç†å‘˜ï¼‰"),
        ]
        # Set commands menu for all users
        await self.app.bot.set_my_commands(commands)
        print("ğŸ“‹ Bot commands menu configured")

    async def run(self):
        """Run the bot (async)."""
        print("ğŸ¤– Bot starting...")
        await self.app.initialize()
        await self.app.start()
        # Setup bot commands menu
        await self._setup_commands()
        print("âœ… Bot is running! Send /start to test.")
        await self.app.updater.start_polling(drop_pending_updates=True)
        # Keep running - wait for stop signal
        try:
            # Create an event that will never be set, keeping the loop alive
            stop_event = asyncio.Event()
            await stop_event.wait()
        except KeyboardInterrupt:
            print("\nğŸ›‘ Received stop signal...")
        finally:
            await self.app.updater.stop()
            await self.app.stop()
            await self.app.shutdown()

    async def stop(self):
        if self.app.updater:
            await self.app.updater.stop()
        await self.app.stop()
        await self.app.shutdown()


def chain_hint(address: str) -> str:
    if address.startswith("0x") and len(address) == 42:
        return "bsc"
    if len(address) >= 32 and len(address) <= 44:
        return "solana"
    return "bsc"


def _maybe_float(s: str):
    try:
        return float(s)
    except Exception:
        raise ValueError("not a number")

--- File: ./src/utils.py ---
from __future__ import annotations

from typing import Optional, Tuple

from .models import FilterRange


def check_range(value: Optional[float], r: FilterRange) -> Tuple[bool, str | None]:
    if not r.is_set():
        return True, None
    if value is None:
        return False, "missing"
    if r.min is not None and value < r.min:
        return False, f"< {r.min}"
    if r.max is not None and value > r.max:
        return False, f"> {r.max}"
    return True, None


def short_num(num: Optional[float]) -> str:
    if num is None:
        return "N/A"
    if abs(num) < 1:
        return f"{num:.8f}"
    for unit in ["", "K", "M", "B"]:
        if abs(num) < 1000.0:
            if unit == "":
                return f"{num:.2f}"
            return f"{num:.2f}{unit}"
        num /= 1000.0
    return f"{num:.2f}T"

def format_time_ago(dt) -> str:
    """Format datetime as 'Xå°æ—¶Yåˆ†é’Ÿ' or 'Yåˆ†é’Ÿ'."""
    if dt is None:
        return "N/A"
    from datetime import datetime
    now = datetime.utcnow()
    
    # éªŒè¯æ—¶é—´åˆç†æ€§ï¼šä¸èƒ½æ˜¯1970å¹´ä¹‹å‰æˆ–æœªæ¥æ—¶é—´
    if dt < datetime(2020, 1, 1) or dt > now:
        # å¦‚æœæ˜¯æœªæ¥æ—¶é—´ï¼Œè¿”å›"åˆšåˆš"
        if dt > now:
            return "åˆšåˆš"
        # å¦‚æœæ˜¯å¾ˆæ—©çš„æ—¶é—´ï¼ˆå¯èƒ½æ˜¯é”™è¯¯çš„æ—¶é—´æˆ³ï¼‰ï¼Œè¿”å›"N/A"
        return "N/A"
    
    diff = now - dt
    total_minutes = int(diff.total_seconds() / 60)
    
    # å¦‚æœæ—¶é—´å·®ä¸ºè´Ÿæ•°æˆ–å¼‚å¸¸å¤§ï¼Œè¿”å›"N/A"
    if total_minutes < 0 or total_minutes > 1000000:  # çº¦694å¤©
        return "N/A"
    
    if total_minutes < 60:
        return f"{total_minutes}åˆ†é’Ÿ"
    hours = total_minutes // 60
    minutes = total_minutes % 60
    if minutes == 0:
        return f"{hours}å°æ—¶"
    return f"{hours}å°æ—¶{minutes}åˆ†é’Ÿ"


--- File: ./src/storage.py ---
from __future__ import annotations

import asyncio
import logging
import time
from typing import Optional

logger = logging.getLogger("ca_filter_bot.storage")


class DedupeStore:
    """å†…å­˜å»é‡å­˜å‚¨ï¼Œä¸ä½¿ç”¨Redis"""
    def __init__(self):
        self.memory = {}
        self.lock = asyncio.Lock()
        self._last_cleanup = 0
        self._cleanup_interval = 300  # æ¯5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡

    async def seen(self, key: str, ttl: int = 900) -> bool:
        """æ£€æŸ¥keyæ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™æ·»åŠ å¹¶è¿”å›Falseï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›True"""
        try:
            async with self.lock:
                now = time.time()
                
                # å®šæœŸæ¸…ç†è¿‡æœŸé¡¹ï¼ˆé¿å…æ¯æ¬¡éƒ½æ¸…ç†ï¼‰
                if now - self._last_cleanup > self._cleanup_interval:
                    expired_count = 0
                    for k, v in list(self.memory.items()):
                        if v < now:
                            self.memory.pop(k, None)
                            expired_count += 1
                    if expired_count > 0:
                        logger.debug(f"ğŸ§¹ Cleaned up {expired_count} expired dedupe entries")
                    self._last_cleanup = now
                
                # æ£€æŸ¥keyæ˜¯å¦å­˜åœ¨
                if key in self.memory and self.memory[key] > now:
                    logger.debug(f"â­ï¸  Key already seen: {key[:16]}...")
                    return True
                
                # æ·»åŠ æ–°key
                self.memory[key] = now + ttl
                logger.debug(f"âœ… Key added to dedupe: {key[:16]}...")
                return False
        except Exception as e:
            logger.error(f"âŒ Error in dedupe.seen: {e}", exc_info=True)
            # å‡ºé”™æ—¶è¿”å›Falseï¼Œå…è®¸å¤„ç†ç»§ç»­
            return False


--- File: ./src/gmgn_basic.py ---
from __future__ import annotations

import asyncio
import logging
from datetime import datetime
from typing import Any, Dict, Optional

import tls_client
from fake_useragent import UserAgent
from tenacity import retry, stop_after_attempt, wait_exponential

from .models import TokenMetrics

logger = logging.getLogger("ca_filter_bot.gmgn_basic")


class GMGNBasicFetcher:
    """
    è½»é‡ç‰ˆ GMGN æŠ“å–å™¨ï¼Œå¤ç”¨ gmgn_complete_fetcher.py çš„åŸºç¡€æ¥å£é€»è¾‘ï¼š
    - ä»…è°ƒç”¨ /api/v1/mutil_window_token_info
    - å…¼å®¹ç§’/æ¯«ç§’æ—¶é—´æˆ³
    - æ”¯æŒé‡è¯•æœºåˆ¶å’ŒæŒ‡çº¹åˆ‡æ¢
    - å°½é‡å°‘å­—æ®µï¼Œé€Ÿåº¦å¿«ï¼Œé€‚åˆå¹¶è¡Œè°ƒç”¨
    """

    BASE_URL = "https://gmgn.ai"
    
    # å¯ç”¨çš„æµè§ˆå™¨æŒ‡çº¹åˆ—è¡¨ï¼ˆç”¨äºé‡è¯•æ—¶åˆ‡æ¢ï¼‰
    FINGERPRINTS = [
        "chrome_124",
        "chrome_120",
        "chrome_116",
        "firefox_120",
        "safari_ios_17_0",
    ]

    def __init__(self, extra_headers: Optional[Dict[str, str]] = None):
        self.fingerprint_index = 0
        self.extra_headers = extra_headers or {}
        self._create_session()

    def _create_session(self):
        """åˆ›å»ºæ–°çš„sessionï¼Œä½¿ç”¨å½“å‰æŒ‡çº¹"""
        fingerprint = self.FINGERPRINTS[self.fingerprint_index % len(self.FINGERPRINTS)]
        self.session = tls_client.Session(
            client_identifier=fingerprint,
            random_tls_extension_order=True,
        )
        self.session.timeout_seconds = 20
        logger.debug(f"ğŸ”„ Created new session with fingerprint: {fingerprint}")

    def _rotate_fingerprint(self):
        """åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæŒ‡çº¹"""
        self.fingerprint_index = (self.fingerprint_index + 1) % len(self.FINGERPRINTS)
        self._create_session()
        logger.info(f"ğŸ”„ Rotated to fingerprint: {self.FINGERPRINTS[self.fingerprint_index]}")

    def _headers(self, chain_code: str) -> Dict[str, str]:
        try:
            ua = UserAgent().random
        except Exception:
            ua = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            )
        headers = {
            "Host": "gmgn.ai",
            "accept": "application/json, text/plain, */*",
            "accept-language": "en-US,en;q=0.9",
            "referer": f"https://gmgn.ai/?chain={chain_code}",
            "user-agent": ua,
            "Content-Type": "application/json",
        }
        headers.update(self.extra_headers)
        return headers

    def _safe_float(self, value: Any) -> float:
        try:
            if value is None:
                return 0.0
            return float(value)
        except Exception:
            return 0.0

    def _normalize_timestamp(self, ts: Any) -> Optional[datetime]:
        """å…¼å®¹ç§’/æ¯«ç§’çš„æ—¶é—´æˆ³ï¼Œæ— æ³•è§£ææ—¶è¿”å› None"""
        try:
            if ts is None:
                return None
            if isinstance(ts, str):
                ts = ts.strip()
                if not ts:
                    return None
                ts = float(ts)
            if ts > 1e12:  # æ¯«ç§’
                ts = ts / 1000.0
            return datetime.fromtimestamp(ts)
        except Exception:
            return None

    def _to_metrics(self, chain: str, address: str, basic: Dict[str, Any]) -> TokenMetrics:
        """å®Œå…¨æŒ‰ç…§ gmgn_complete_fetcher.py çš„é€»è¾‘æå–æ•°æ®"""
        # 1. ä»·æ ¼å¤„ç†ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
        raw_price = basic.get("price")
        price = 0.0
        if isinstance(raw_price, dict):
            price = self._safe_float(raw_price.get("price"))
        else:
            price = self._safe_float(raw_price)
        
        price_obj = basic.get("price") or {}
        pool_obj = basic.get("pool") or {}
        dev_obj = basic.get("dev") or {}
        
        # 2. å¸‚å€¼è®¡ç®—ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
        total_supply = self._safe_float(basic.get("total_supply"))
        market_cap = self._safe_float(basic.get("market_cap"))
        if market_cap == 0 and price > 0 and total_supply > 0:
            market_cap = price * total_supply

        # 3. æ± å­å¤§å°ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
        liquidity = self._safe_float(pool_obj.get("liquidity"))

        # 4. å¼€ç›˜æ—¶é—´ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
        ts_candidates = [
            basic.get("open_timestamp"),
            basic.get("launch_time"),
            # ä¼˜å…ˆä½¿ç”¨æ± å­åˆ›å»ºæ—¶é—´ï¼Œé¿å…â€œæ‰“æ»¡â€æ—¶é—´åç§»
            pool_obj.get("pool_created_at") if isinstance(pool_obj, dict) else None,
            pool_obj.get("pair_created_at") if isinstance(pool_obj, dict) else None,
            pool_obj.get("created_at") if isinstance(pool_obj, dict) else None,
            pool_obj.get("open_timestamp") if isinstance(pool_obj, dict) else None,
            price_obj.get("open_timestamp") if isinstance(price_obj, dict) else None,
        ]
        open_dt = None
        for ts in ts_candidates:
            open_dt = self._normalize_timestamp(ts)
            if open_dt:
                break

        # 5. å‰åæŒä»“ï¼ˆå®Œå…¨ä¸€è‡´ï¼šç›´æ¥è·å–ï¼Œä¸åšç™¾åˆ†æ¯”è½¬æ¢ï¼‰
        top10_raw = dev_obj.get("top_10_holder_rate")
        top10_ratio = self._safe_float(top10_raw)
        # å¦‚æœå€¼ > 1ï¼Œè¯´æ˜æ˜¯ç™¾åˆ†æ¯”å½¢å¼ï¼ˆå¦‚14.98ï¼‰ï¼Œéœ€è¦é™¤ä»¥100è½¬æ¢ä¸ºå°æ•°ï¼ˆ0.1498ï¼‰
        if top10_ratio > 1:
            top10_ratio = top10_ratio / 100.0
        # å¦‚æœä¸º0ï¼Œä¿æŒ0.0ï¼Œä¸è¦è¿”å›None

        # 6. 5åˆ†é’Ÿäº¤æ˜“ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
        trades_5m = 0
        raw_swaps = basic.get("price", {})
        if isinstance(raw_swaps, dict):
            swaps = raw_swaps.get("swaps_5m")
            trades_5m = int(swaps or 0)

        # 7. æœ€å¤§æŒä»“ï¼ˆä½¿ç”¨ç¬¬äºŒå¤§æŒä»“è€…ï¼Œä½†åŸºç¡€æ¥å£æ²¡æœ‰æŒä»“è¯¦æƒ…ï¼Œæ‰€ä»¥ä½¿ç”¨ä¼°ç®—å€¼ï¼‰
        # æ³¨æ„ï¼šè¿™é‡Œåªæ˜¯ä¼°ç®—å€¼ï¼ŒçœŸæ­£çš„ç¬¬äºŒå¤§æŒä»“è€…å æ¯”éœ€è¦ä» top holders æ¥å£è·å–
        # å¦‚æœåç»­æœ‰ top holders æ•°æ®ï¼Œä¼šè¢«è¦†ç›–
        max_holder_ratio = top10_ratio / 2.0 if top10_ratio > 0 else 0.0

        return TokenMetrics(
            chain=chain,
            address=address,
            symbol=basic.get("symbol", "") or "",
            name=basic.get("name"),
            price_usd=price,
            price_change_5m=self._safe_float(price_obj.get("price_5m")),
            market_cap=market_cap,
            liquidity_usd=liquidity,
            pool_created_at=open_dt,
            trades_5m=trades_5m,
            holders=int(basic.get("holder_count") or 0),
            top10_ratio=top10_ratio,  # ä¿æŒ0.0è€Œä¸æ˜¯None
            max_holder_ratio=max_holder_ratio,  # ä¿æŒ0.0è€Œä¸æ˜¯None
            extra={"source": "gmgn_basic"},
        )

    def _fetch_sync(self, chain: str, address: str, attempt: int = 0) -> Optional[TokenMetrics]:
        """åŒæ­¥è·å–ï¼Œå¸¦é‡è¯•å’ŒæŒ‡çº¹åˆ‡æ¢æœºåˆ¶"""
        chain_code = "sol" if chain.lower() in ("solana", "sol") else chain.lower()
        url = f"{self.BASE_URL}/api/v1/mutil_window_token_info"
        payload = {"chain": chain_code, "addresses": [address]}

        try:
            resp = self.session.post(url, json=payload, headers=self._headers(chain_code))
            if resp.status_code != 200:
                logger.warning(f"GMGN basic API returned {resp.status_code} for {address[:8]} (attempt {attempt + 1})")
                # å¦‚æœæ˜¯403/429ç­‰é”™è¯¯ï¼Œåˆ‡æ¢æŒ‡çº¹é‡è¯•
                if resp.status_code in (403, 429, 401) and attempt < len(self.FINGERPRINTS) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to HTTP {resp.status_code}")
                    self._rotate_fingerprint()
                    return self._fetch_sync(chain, address, attempt + 1)
                return None
            data = resp.json()
            if data.get("code") != 0 or not data.get("data"):
                logger.debug(f"GMGN basic API error: code={data.get('code')}, msg={data.get('msg')} (attempt {attempt + 1})")
                # å¦‚æœAPIè¿”å›é”™è¯¯ç ï¼Œä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹
                if attempt < len(self.FINGERPRINTS) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to API error code={data.get('code')}")
                    self._rotate_fingerprint()
                    return self._fetch_sync(chain, address, attempt + 1)
                return None
            basic = data["data"][0]
            # æå– pairAddress ç”¨äºå›¾è¡¨
            pair_address = None
            if "pool" in basic and isinstance(basic["pool"], dict):
                pool = basic["pool"]
                pair_address = pool.get("pair_address") or pool.get("address") or pool.get("pairAddress")
                logger.debug(f"ğŸ“Š Pool keys: {list(pool.keys())}, pair_address: {pair_address}")
            else:
                logger.debug(f"ğŸ“Š No pool data in basic info, pool type: {type(basic.get('pool'))}")
            metrics = self._to_metrics(chain, address, basic)
            if pair_address and metrics:
                metrics.extra["pairAddress"] = pair_address
                logger.debug(f"âœ… Extracted pairAddress: {pair_address[:16]}...")
            else:
                logger.warning(f"âš ï¸ Failed to extract pairAddress from GMGN basic info")
            return metrics
        except Exception as e:
            logger.warning(f"GMGN basic fetch error for {address[:8]}: {e} (attempt {attempt + 1})")
            # å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–å¼‚å¸¸ï¼Œå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
            if attempt < len(self.FINGERPRINTS) - 1:
                logger.info(f"ğŸ”„ Switching fingerprint due to exception: {type(e).__name__}")
                self._rotate_fingerprint()
                return self._fetch_sync(chain, address, attempt + 1)
            # æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼Œè¿”å›None
            return None

    async def fetch(self, chain: str, address: str) -> Optional[TokenMetrics]:
        """å¼‚æ­¥åŒ…è£…ï¼Œé¿å…é˜»å¡äº‹ä»¶å¾ªç¯"""
        return await asyncio.to_thread(self._fetch_sync, chain, address)


--- File: ./src/data_fetcher.py ---
from __future__ import annotations

import logging
import random
import asyncio
import time
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple

import httpx
from curl_cffi import requests as curl_requests
from tenacity import retry, stop_after_attempt, wait_exponential

from .models import TokenMetrics
from .gmgn_basic import GMGNBasicFetcher

logger = logging.getLogger("ca_filter_bot.data_fetcher")


DEX_TOKEN_URL = "https://api.dexscreener.com/latest/dex/tokens/{address}"
SOL_SNIFFER_API_KEY = "gbnyroq3tsblgsm8c9nofinecwmecd"
TOKEN_SNIFFER_API_KEY = "d69930b10c2b535db46463568fcfa38a7d9c5e95"


class DataFetcher:
    def __init__(
        self,
        session: Optional[httpx.AsyncClient] = None,
        gmgn_headers: Optional[Dict[str, str]] = None,
    ):
        # verify=False ä»…ç”¨äºè°ƒè¯•ï¼Œç”Ÿäº§ç¯å¢ƒå»ºè®®è®¾ä¸º True
        self.client = session or httpx.AsyncClient(timeout=15, verify=True)
        self.gmgn_headers = gmgn_headers or {}
        self.gmgn_basic = GMGNBasicFetcher(extra_headers=self.gmgn_headers)

    async def fetch_all(self, chain: str, address: str) -> TokenMetrics:
        logger.info(f"ğŸ” Fetching data for {chain} - {address[:8]}...")

        # 1) ä¼˜å…ˆä½¿ç”¨ GMGN åŸºç¡€æ¥å£ï¼ˆtls_clientï¼Œå¸¦é‡è¯•ï¼Œå¿«é€Ÿï¼‰
        metrics = await self.gmgn_basic.fetch(chain, address)
        if metrics:
            logger.info("âœ… GMGN basic interface success")
            # å³ä½¿åŸºç¡€æ¥å£æˆåŠŸï¼Œä¹Ÿå°è¯•è·å– top holders æ•°æ®æ¥æ›´æ–° max_holder_ratio
            holders_data = await self._fetch_gmgn_top_holders(chain, address)
            if holders_data and holders_data.get("max_holder_ratio") is not None:
                metrics.max_holder_ratio = holders_data["max_holder_ratio"]
                logger.info(f"âœ… Updated max_holder_ratio from top holders: {metrics.max_holder_ratio:.4f}")
        else:
            # 2) GMGN åŸºç¡€æ¥å£å¤±è´¥ï¼Œå°è¯•å…¨é‡æ¥å£ï¼ˆcurl_cffiï¼‰
            logger.info("âš ï¸ GMGN basic failed, trying full interface...")
            metrics = await self._fetch_gmgn(chain, address)
            if not metrics:
                # 3) DexScreener å›é€€
                logger.info("âš ï¸ GMGN failed, switching to DexScreener...")
                metrics = await self._fetch_dex(chain, address)

        # 4) è·å–é£é™©è¯„åˆ†ï¼ˆSolSniffer å’Œ TokenSnifferï¼‰
        if metrics:
            await self._fetch_risk_scores(metrics)
            logger.info(f"âœ… Risk scores fetched: SolSniffer={metrics.sol_sniffer_score}, TokenSniffer={metrics.token_sniffer_score}")

        return metrics
    

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=0.5, min=0.5, max=4))
    async def _fetch_dex(self, chain: str, address: str) -> TokenMetrics:
        url = DEX_TOKEN_URL.format(address=address)
        r = await self.client.get(url)
        r.raise_for_status()
        data = r.json()
        pairs = data.get("pairs") or []
        
        if not pairs:
            raise ValueError("No pairs found on DexScreener")
            
        pair = _select_pair(pairs, chain)
        
        # æå–å­—æ®µ
        market_cap = _to_float(pair.get("fdv")) or _to_float(pair.get("marketCap"))
        liquidity = _to_float(pair.get("liquidity", {}).get("usd"))
        trades_5m = _to_int(pair.get("txns", {}).get("m5", {}).get("buys", 0)) + \
                    _to_int(pair.get("txns", {}).get("m5", {}).get("sells", 0))

        metrics = TokenMetrics(
            chain=pair.get("chainId", chain),
            address=address,
            symbol=pair.get("baseToken", {}).get("symbol", ""),
            name=pair.get("baseToken", {}).get("name"),
            price_usd=_to_float(pair.get("priceUsd")),
            price_change_5m=_to_float(pair.get("priceChange", {}).get("m5")),
            market_cap=market_cap,
            liquidity_usd=liquidity,
            trades_5m=trades_5m,
            pool_created_at=_to_datetime(pair.get("pairCreatedAt")),
            # è¿™é‡Œçš„ pairAddress å¾ˆé‡è¦ï¼Œç”¨äºåç»­æŸ¥ K çº¿
            extra={"pairAddress": pair.get("pairAddress"), "source": "dex"},
        )
        return metrics

    # --- GeckoTerminal OHLCVï¼ˆ1mï¼Œ1å°æ—¶å†…ï¼‰ ---
    def _gecko_network(self, chain: str) -> Optional[str]:
        """
        å°†å†…éƒ¨é“¾åç§°æ˜ å°„åˆ° GeckoTerminal çš„ network å‚æ•°ã€‚
        ç›®å‰ä¸»è¦æ”¯æŒï¼šSolanaã€BSCï¼Œå…¶ä»–é“¾å¯æŒ‰éœ€æ‰©å±•ã€‚
        """
        c = chain.lower()
        if c in ("sol", "solana"):
            return "solana"
        if c in ("bsc", "bscscan", "bnb"):
            return "bsc"
        if c in ("eth", "ethereum"):
            return "eth"
        return None
    
    async def fetch_chart_by_address(self, chain: str, address: str, minutes: int = 60) -> List[Dict[str, Any]]:
        """
        ä½¿ç”¨ GeckoTerminal API è·å– K çº¿æ•°æ®ã€‚
        è¿”å›æ ¼å¼: {t, o, h, l, c, v}
        """
        return await self._fetch_gecko_ohlcv(chain, address, minutes)
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=0.5, min=0.5, max=4))
    async def fetch_chart(self, metrics: TokenMetrics, minutes: int = 60) -> List[Dict[str, Any]]:
        """
        ä½¿ç”¨ GeckoTerminal API è·å– K çº¿æ•°æ®ï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰ã€‚
        """
        return await self.fetch_chart_by_address(metrics.chain, metrics.address, minutes)
    
    async def _fetch_gecko_ohlcv(self, chain: str, address: str, minutes: int) -> List[Dict[str, Any]]:
        """
        å†…éƒ¨æ–¹æ³•ï¼šä½¿ç”¨ GeckoTerminal API è·å– 1m K çº¿æ•°æ®ï¼ˆæœ€è¿‘ minutes åˆ†é’Ÿï¼Œé€šå¸¸ 60ï¼‰ã€‚
        æ–‡æ¡£ç¤ºä¾‹ï¼š
        1) /api/v2/networks/{network}/tokens/{token}/pools  -> è·å–æ± å­
        2) /api/v2/networks/{network}/pools/{pool}/ohlcv/minute?aggregate=1&limit=60&currency=usd
        """
        network = self._gecko_network(chain)
        if not network:
            raise ValueError(f"GeckoTerminal does not support chain: {chain}")
        
        # 1. æ ¹æ® token æ‰¾åˆ°æ± å­ï¼ˆå–ç¬¬ä¸€ä¸ªï¼‰
        pools_url = f"https://api.geckoterminal.com/api/v2/networks/{network}/tokens/{address}/pools"
        logger.info(f"ğŸ“Š Fetching GeckoTerminal pools for {address[:8]}... (network={network})")
        try:
            pools_resp = await self.client.get(pools_url, timeout=10)
            pools_resp.raise_for_status()
            pools_data = pools_resp.json()
        except Exception as e:
            logger.warning(f"âš ï¸ GeckoTerminal pools API failed: {e}")
            raise ValueError(f"GeckoTerminal: failed to fetch pools - {str(e)}")
        
        pool_list = pools_data.get("data") or []
        if not pool_list:
            raise ValueError("GeckoTerminal: no pools found for token")
        
        pool_attrs = pool_list[0].get("attributes") or {}
        pool_address = pool_attrs.get("address")
        if not pool_address:
            raise ValueError("GeckoTerminal: pool address missing in response")
        
        logger.info(f"âœ… GeckoTerminal pool selected: {pool_address}")
        
        # 2. è·å–è¯¥æ± å­çš„åˆ†é’Ÿ OHLCVï¼ˆlimit=minutesï¼Œæœ€å¤š60ï¼‰
        limit = min(max(minutes, 1), 60)
        ohlcv_url = (
            f"https://api.geckoterminal.com/api/v2/networks/{network}/pools/"
            f"{pool_address}/ohlcv/minute?aggregate=1&limit={limit}&currency=usd"
        )
        logger.info(f"ğŸ“Š Fetching GeckoTerminal OHLCV (1m, last {limit} bars)...")
        try:
            k_resp = await self.client.get(ohlcv_url, timeout=10)
            k_resp.raise_for_status()
            k_data = k_resp.json()
        except Exception as e:
            logger.warning(f"âš ï¸ GeckoTerminal OHLCV API failed: {e}")
            raise ValueError(f"GeckoTerminal: failed to fetch OHLCV - {str(e)}")
        
        attrs = (k_data.get("data") or {}).get("attributes") or {}
        ohlcv_list = attrs.get("ohlcv_list") or []
        if not ohlcv_list:
            raise ValueError("GeckoTerminal: ohlcv_list is empty")
        
        bars: List[Dict[str, Any]] = []
        for item in ohlcv_list:
            # é¢„æœŸæ ¼å¼: [timestamp, open, high, low, close, volume]
            if not isinstance(item, (list, tuple)) or len(item) < 5:
                logger.debug(f"âš ï¸ Skipping invalid Gecko bar: {item}")
                continue
            ts = item[0]
            o, h, l, c = item[1], item[2], item[3], item[4]
            v = item[5] if len(item) > 5 else 0
            try:
                bars.append(
                    {
                        "t": int(ts),        # ç§’çº§æ—¶é—´æˆ³
                        "o": float(o),
                        "h": float(h),
                        "l": float(l),
                        "c": float(c),
                        "v": float(v),
                    }
                )
            except Exception:
                logger.debug(f"âš ï¸ Failed to convert Gecko bar: {item}")
                continue
        
        if not bars:
            raise ValueError("GeckoTerminal: no valid bars after conversion")
        
        # Gecko è¿”å›é€šå¸¸æ˜¯æŒ‰æ—¶é—´å‡åºæˆ–é™åºï¼Œè¿™é‡Œç»Ÿä¸€æŒ‰æ—¶é—´æ’åº
        bars.sort(key=lambda x: x["t"])
        
        # åªä¿ç•™æœ€è¿‘60æ ¹Kçº¿ï¼ˆ1å°æ—¶ï¼‰
        if len(bars) > 60:
            bars = bars[-60:]
            logger.info(f"âš ï¸ GeckoTerminal returned {len(bars)} bars, keeping only last 60 bars")
        
        logger.info(f"âœ… GeckoTerminal OHLCV: fetched {len(bars)} bars "
                    f"(from {bars[0]['t']} to {bars[-1]['t']})")
        return bars

    def _get_gmgn_headers(self, referer_path: str) -> Dict[str, str]:
        """æ„é€ é«˜ä»¿æµè§ˆå™¨å¤´ï¼ˆå‚è€ƒç”¨æˆ·æä¾›çš„æ–¹æ¡ˆï¼‰"""
        # éšæœºåŒ– User-Agent
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
        ]
        ua = random.choice(user_agents)
        
        # åˆå¹¶ç”¨æˆ·æä¾›çš„ headers
        headers = {
            "User-Agent": ua,
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "en-US,en;q=0.9",
            "Origin": "https://gmgn.ai",
            "Referer": f"https://gmgn.ai{referer_path}",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
        }
        
        # å¦‚æœç”¨æˆ·æä¾›äº†è‡ªå®šä¹‰ headersï¼ˆå¦‚ Cookieï¼‰ï¼Œåˆå¹¶è¿›å»
        if self.gmgn_headers:
            headers.update(self.gmgn_headers)
        
        return headers

    async def _fetch_gmgn_token_info(self, chain: str, address: str, attempt: int = 0) -> Optional[Dict[str, Any]]:
        """è¯·æ±‚ä¸»æ¥å£ï¼š/defi/quotation/v1/tokens/sol/{address} - è·å–ä»·æ ¼ã€å¸‚å€¼ç­‰"""
        # å¯ç”¨çš„æµè§ˆå™¨æŒ‡çº¹åˆ—è¡¨ï¼ˆç”¨äºé‡è¯•æ—¶åˆ‡æ¢ï¼‰
        fingerprints = ["chrome110", "chrome120", "chrome116", "safari15_3", "safari15_5"]
        
        chain_code = "sol" if chain.lower() == "solana" else "eth"
        if chain.lower() == "bsc":
            chain_code = "bsc"
        
        url = f"https://gmgn.ai/defi/quotation/v1/tokens/{chain_code}/{address}"
        headers = self._get_gmgn_headers(f"/{chain_code}/token/{address}")
        
        try:
            # ä½¿ç”¨ curl_cffi çš„æŒ‡çº¹ç»•è¿‡ Cloudflareï¼Œå¤±è´¥æ—¶åˆ‡æ¢æŒ‡çº¹
            fingerprint = fingerprints[attempt % len(fingerprints)]
            logger.info(f"ğŸ” Fetching GMGN token info: {url} (attempt {attempt + 1}, fingerprint: {fingerprint})")
            resp = await asyncio.to_thread(
                curl_requests.get,
                url,
                headers=headers,
                impersonate=fingerprint,
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                
                if data.get("code") == 0:
                    token = data.get("data", {}).get("token", {})
                    if token:
                        logger.info(f"âœ… GMGN token info fetched: {token.get('symbol', 'N/A')}")
                        return token
                    else:
                        logger.warning(f"âš ï¸  GMGN token data is empty")
                else:
                    logger.warning(f"âš ï¸  GMGN API error: code={data.get('code')}, msg={data.get('msg')}")
            elif resp.status_code == 403:
                logger.warning(f"ğŸš« GMGN Token Info 403 Blocked (attempt {attempt + 1})")
                # 403é”™è¯¯ï¼Œåˆ‡æ¢æŒ‡çº¹é‡è¯•
                if attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to 403")
                    return await self._fetch_gmgn_token_info(chain, address, attempt + 1)
            elif resp.status_code == 429:
                logger.warning(f"ğŸš« GMGN Token Info 429 Rate Limit (attempt {attempt + 1})")
                # 429é”™è¯¯ï¼Œåˆ‡æ¢æŒ‡çº¹é‡è¯•
                if attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to 429")
                    return await self._fetch_gmgn_token_info(chain, address, attempt + 1)
            else:
                logger.warning(f"âš ï¸  GMGN Token Info HTTP {resp.status_code} (attempt {attempt + 1})")
                # å…¶ä»–é”™è¯¯ä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹
                if resp.status_code >= 400 and attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to HTTP {resp.status_code}")
                    return await self._fetch_gmgn_token_info(chain, address, attempt + 1)
        except Exception as e:
            logger.warning(f"âŒ GMGN Token Info Error: {type(e).__name__}: {e} (attempt {attempt + 1})")
            # å¼‚å¸¸æ—¶ä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
            if attempt < len(fingerprints) - 1:
                logger.info(f"ğŸ”„ Switching fingerprint due to exception")
                return await self._fetch_gmgn_token_info(chain, address, attempt + 1)
        
        return None
    
    async def _fetch_gmgn_basic_info(self, chain: str, address: str, attempt: int = 0) -> Optional[Dict[str, Any]]:
        """
        å¤‡ç”¨æ–¹æ¡ˆï¼šè·å–åŸºç¡€ä¿¡æ¯ï¼ˆä½ å·²ç»èƒ½è·å–åˆ°çš„æ¥å£ï¼‰
        æ¥å£: /api/v1/mutil_window_token_info
        """
        # å¯ç”¨çš„æµè§ˆå™¨æŒ‡çº¹åˆ—è¡¨ï¼ˆç”¨äºé‡è¯•æ—¶åˆ‡æ¢ï¼‰
        fingerprints = ["chrome110", "chrome120", "chrome116", "safari15_3", "safari15_5"]
        
        chain_code = "sol" if chain.lower() == "solana" else "eth"
        if chain.lower() == "bsc":
            chain_code = "bsc"
        
        url = f"https://gmgn.ai/api/v1/mutil_window_token_info"
        headers = self._get_gmgn_headers(f"/?chain={chain_code}")
        # POST è¯·æ±‚éœ€è¦ content-type
        headers["Content-Type"] = "application/json"
        payload = {"chain": chain_code, "addresses": [address]}
        
        try:
            fingerprint = fingerprints[attempt % len(fingerprints)]
            logger.info(f"ğŸ” Fetching GMGN basic info (backup): {url} (attempt {attempt + 1}, fingerprint: {fingerprint})")
            resp = await asyncio.to_thread(
                curl_requests.post,
                url,
                headers=headers,
                json=payload,
                impersonate=fingerprint,
                timeout=10
            )
            
            
            if resp.status_code == 200:
                data = resp.json()
                if data.get("code") == 0 and data.get("data"):
                    basic_info = data["data"][0] if data["data"] else None
                    if basic_info:
                        logger.info(f"âœ… GMGN basic info (backup) fetched: {basic_info.get('symbol', 'N/A')}")
                        return basic_info
                else:
                    # APIè¿”å›é”™è¯¯ï¼Œå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
                    if attempt < len(fingerprints) - 1:
                        logger.info(f"ğŸ”„ Switching fingerprint due to API error code={data.get('code')}")
                        return await self._fetch_gmgn_basic_info(chain, address, attempt + 1)
            elif resp.status_code in (403, 429, 401):
                logger.warning(f"ğŸš« GMGN Basic Info HTTP {resp.status_code} (attempt {attempt + 1})")
                # 403/429é”™è¯¯ï¼Œåˆ‡æ¢æŒ‡çº¹é‡è¯•
                if attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to HTTP {resp.status_code}")
                    return await self._fetch_gmgn_basic_info(chain, address, attempt + 1)
        except Exception as e:
            logger.debug(f"âŒ GMGN Basic Info Error: {e} (attempt {attempt + 1})")
            # å¼‚å¸¸æ—¶ä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
            if attempt < len(fingerprints) - 1:
                logger.info(f"ğŸ”„ Switching fingerprint due to exception")
                return await self._fetch_gmgn_basic_info(chain, address, attempt + 1)
        
        return None

    async def _fetch_gmgn_top_holders(self, chain: str, address: str, attempt: int = 0) -> Optional[Dict[str, Any]]:
        """è¯·æ±‚æŒä»“æ¥å£ï¼š/vas/api/v1/token_holders/sol/{address} - è·å–ç²¾ç¡®çš„ Top10 å’Œ Max Holderï¼ˆå‚è€ƒ Dragonï¼‰"""
        # å¯ç”¨çš„æµè§ˆå™¨æŒ‡çº¹åˆ—è¡¨ï¼ˆç”¨äºé‡è¯•æ—¶åˆ‡æ¢ï¼‰
        fingerprints = ["chrome110", "chrome120", "chrome116", "safari15_3", "safari15_5"]
        
        chain_code = "sol" if chain.lower() == "solana" else "eth"
        if chain.lower() == "bsc":
            chain_code = "bsc"
        
        # ä½¿ç”¨ Dragon ä¸­éªŒè¯è¿‡çš„æ¥å£åœ°å€
        url = f"https://gmgn.ai/vas/api/v1/token_holders/{chain_code}/{address}"
        params = {"orderby": "amount_percentage", "direction": "desc", "limit": 20}
        headers = self._get_gmgn_headers(f"/{chain_code}/token/{address}")
        
        try:
            fingerprint = fingerprints[attempt % len(fingerprints)]
            logger.debug(f"ğŸ” Fetching GMGN top holders (attempt {attempt + 1}, fingerprint: {fingerprint})")
            resp = await asyncio.to_thread(
                curl_requests.get,
                url,
                params=params,
                headers=headers,
                impersonate=fingerprint,
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                # Dragon ä½¿ç”¨çš„æ¥å£è¿”å›æ ¼å¼å¯èƒ½æ˜¯ data.list æˆ– data.data.list
                holders_list = data.get("data", {}).get("list", []) or data.get("data", []) or data.get("list", [])
                
                if holders_list:
                    # è®¡ç®— Top 10 å’Œ Max
                    # æ³¨æ„ï¼šGMGN è¿”å›çš„å¯èƒ½æ˜¯ç™¾åˆ†æ¯”(å¦‚30.5)ä¹Ÿå¯èƒ½æ˜¯å°æ•°(0.305)ï¼Œéœ€è¦åˆ¤æ–­
                    top10_sum = 0.0
                    max_holder = 0.0
                    
                    for h in holders_list[:10]:
                        pct = float(h.get("amount_percentage", 0))
                        # å¦‚æœå€¼ > 1ï¼Œè¯´æ˜æ˜¯ç™¾åˆ†æ¯”å½¢å¼ï¼Œéœ€è¦é™¤ä»¥100
                        if pct > 1:
                            pct = pct / 100
                        top10_sum += pct
                    
                    # è·å–ç¬¬äºŒå¤§æŒä»“è€…çš„å æ¯”ï¼ˆè€Œä¸æ˜¯æœ€å¤§çš„ï¼‰
                    if len(holders_list) >= 2:
                        # ç¬¬äºŒå¤§æŒä»“è€…æ˜¯ç´¢å¼•1ï¼ˆç´¢å¼•0æ˜¯æœ€å¤§çš„ï¼‰
                        second_max_pct = float(holders_list[1].get("amount_percentage", 0))
                        if second_max_pct > 1:
                            second_max_pct = second_max_pct / 100
                        max_holder = second_max_pct
                    elif len(holders_list) == 1:
                        # å¦‚æœåªæœ‰ä¸€ä¸ªæŒä»“è€…ï¼Œä½¿ç”¨å®ƒçš„å€¼
                        max_pct = float(holders_list[0].get("amount_percentage", 0))
                        if max_pct > 1:
                            max_pct = max_pct / 100
                        max_holder = max_pct
                    else:
                        max_holder = 0.0
                    
                    logger.info(f"âœ… GMGN top holders fetched: top10={top10_sum:.4f}, second_max={max_holder:.4f}")
                    return {
                        "top_10_ratio": top10_sum,
                        "max_holder_ratio": max_holder
                    }
                else:
                    # æ²¡æœ‰æ•°æ®ï¼Œå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
                    if attempt < len(fingerprints) - 1:
                        logger.info(f"ğŸ”„ Switching fingerprint due to empty data")
                        return await self._fetch_gmgn_top_holders(chain, address, attempt + 1)
            elif resp.status_code in (403, 429, 401):
                logger.warning(f"ğŸš« GMGN Top Holders HTTP {resp.status_code} (attempt {attempt + 1})")
                # 403/429é”™è¯¯ï¼Œåˆ‡æ¢æŒ‡çº¹é‡è¯•
                if attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to HTTP {resp.status_code}")
                    return await self._fetch_gmgn_top_holders(chain, address, attempt + 1)
            else:
                logger.warning(f"âš ï¸  GMGN Top Holders HTTP {resp.status_code} (attempt {attempt + 1})")
                # å…¶ä»–é”™è¯¯ä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹
                if resp.status_code >= 400 and attempt < len(fingerprints) - 1:
                    logger.info(f"ğŸ”„ Switching fingerprint due to HTTP {resp.status_code}")
                    return await self._fetch_gmgn_top_holders(chain, address, attempt + 1)
        except Exception as e:
            logger.debug(f"âŒ GMGN Top Holders Error: {e} (attempt {attempt + 1})")
            # å¼‚å¸¸æ—¶ä¹Ÿå°è¯•åˆ‡æ¢æŒ‡çº¹é‡è¯•
            if attempt < len(fingerprints) - 1:
                logger.info(f"ğŸ”„ Switching fingerprint due to exception")
                return await self._fetch_gmgn_top_holders(chain, address, attempt + 1)
        
        return None

    async def _fetch_gmgn(self, chain: str, address: str) -> Optional[TokenMetrics]:
        """
        è·å– GMGN å®Œæ•´æ•°æ®
        ç­–ç•¥ï¼š
        1. ä¼˜å…ˆä½¿ç”¨ä¸»æ¥å£
        2. å¦‚æœå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨åŸºç¡€æ¥å£
        3. å¹¶è¡Œè·å–æŒä»“æ•°æ®
        """
        # å¹¶è¡Œè¯·æ±‚ï¼šä¸»æ¥å£ + æŒä»“æ¥å£
        token_task = self._fetch_gmgn_token_info(chain, address)
        holders_task = self._fetch_gmgn_top_holders(chain, address)
        
        token_data, holders_data = await asyncio.gather(token_task, holders_task)
        
        # å¦‚æœä¸»æ¥å£å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨åŸºç¡€æ¥å£
        if not token_data:
            logger.info(f"âš ï¸  Main GMGN interface failed, trying backup basic interface...")
            basic_info = await self._fetch_gmgn_basic_info(chain, address)
            if basic_info:
                # å°†åŸºç¡€ä¿¡æ¯è½¬æ¢ä¸ºä¸ä¸»æ¥å£ç›¸åŒçš„æ ¼å¼
                token_data = self._convert_basic_to_token_format(basic_info)
                logger.info(f"âœ… Using backup basic info")
        
        # å¦‚æœæ‰€æœ‰æ¥å£éƒ½å¤±è´¥
        if not token_data:
            logger.warning(f"ğŸš« GMGN all endpoints failed. Using DexScreener fallback.")
            return None
        
        # æ•°æ®æå–ä¸ç»„è£…
        merged_data = {}
        
        # 1. å¸‚å€¼ (ä¼˜å…ˆç”¨ API è¿”å›çš„ï¼Œæ²¡æœ‰åˆ™è®¡ç®—)
        price = _to_float(token_data.get("price")) or 0
        mcap = _to_float(token_data.get("market_cap")) or 0
        if mcap == 0 and price > 0:
            total_supply = _to_float(token_data.get("total_supply")) or 0
            if total_supply > 0:
                mcap = price * total_supply
        merged_data["market_cap"] = mcap
        
        # 2. æ± å­å¤§å°
        merged_data["liquidity"] = _to_float(token_data.get("liquidity")) or 0
        
        # 3. å¼€ç›˜æ—¶é—´
        open_ts = token_data.get("open_timestamp") or token_data.get("pool_creation_timestamp")
        merged_data["open_timestamp"] = open_ts
        merged_data["pool_creation_timestamp"] = open_ts
        
        # 4. CA åœ°å€
        merged_data["address"] = token_data.get("address", address)
        merged_data["symbol"] = token_data.get("symbol", "")
        merged_data["name"] = token_data.get("name")
        
        # 5. æŒæœ‰äººæ•°
        merged_data["holder_count"] = _to_int(token_data.get("holder_count"))
        
        # 6. å‰åæŒä»“å æ¯” (ä¼˜å…ˆç”¨ holders æ¥å£è®¡ç®—ï¼Œæ²¡æœ‰åˆ™ç”¨ token æ¥å£çš„ dev å­—æ®µ)
        if holders_data and holders_data.get("top_10_ratio") is not None:
            merged_data["top_10_holder_rate"] = holders_data["top_10_ratio"]
        else:
            # å¤‡ç”¨æ–¹æ¡ˆï¼šä» token æ¥å£çš„ dev å­—æ®µè·å–
            dev_data = token_data.get("dev", {})
            merged_data["top_10_holder_rate"] = _to_float(dev_data.get("top_10_holder_rate")) or 0
        
        # 7. 5åˆ†é’Ÿäº¤æ˜“æ•°
        # GMGN çš„ swaps_5m å­—æ®µï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨ swapsï¼ˆå¯èƒ½æ˜¯24hçš„ï¼‰
        merged_data["swaps_5m"] = _to_int(token_data.get("swaps_5m")) or _to_int(token_data.get("swaps")) or 0
        
        # 8. æœ€å¤§æŒä»“è€…å æ¯”
        if holders_data and holders_data.get("max_holder_ratio") is not None:
            merged_data["max_holder_ratio"] = holders_data["max_holder_ratio"]
        else:
            # å¦‚æœæ²¡æœ‰è¯¦ç»†æ•°æ®ï¼Œå°è¯•ä» top_10_holder_rate ä¼°ç®—
            top10 = merged_data.get("top_10_holder_rate", 0)
            merged_data["max_holder_ratio"] = top10 / 3 if top10 > 0 else None
        
        # å…¶ä»–å­—æ®µ
        merged_data["price"] = price
        merged_data["price_change_percent5m"] = _to_float(token_data.get("price_change_percent5m"))
        
        return self._gmgn_to_metrics(chain, address, merged_data)
    
    def _convert_basic_to_token_format(self, basic_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        å°†åŸºç¡€æ¥å£è¿”å›çš„æ•°æ®è½¬æ¢ä¸ºä¸ä¸»æ¥å£ç›¸åŒçš„æ ¼å¼
        è¿™æ ·åç»­å¤„ç†é€»è¾‘å¯ä»¥ç»Ÿä¸€
        """
        price_data = basic_info.get("price", {})
        pool_data = basic_info.get("pool", {})
        dev_data = basic_info.get("dev", {})
        
        # è®¡ç®—å¸‚å€¼
        price = _to_float(price_data.get("price")) or 0
        total_supply = float(basic_info.get("total_supply", 0) or 0)
        market_cap = price * total_supply if price > 0 and total_supply > 0 else None
        
        return {
            "address": basic_info.get("address", ""),
            "symbol": basic_info.get("symbol", ""),
            "name": basic_info.get("name"),
            "price": price,
            "price_change_percent5m": _to_float(price_data.get("price_5m")),
            "market_cap": market_cap,
            "total_supply": total_supply,
            "liquidity": _to_float(pool_data.get("liquidity")),
            "open_timestamp": basic_info.get("open_timestamp"),
            "pool_creation_timestamp": pool_data.get("creation_timestamp"),
            "swaps_5m": price_data.get("swaps_5m", 0),
            "swaps": price_data.get("swaps_24h", 0),  # 24h äº¤æ˜“æ•°
            "holder_count": basic_info.get("holder_count"),
            "top_10_holder_rate": _to_float(dev_data.get("top_10_holder_rate")),
            "max_holder_ratio": None,
        }

    def _gmgn_to_metrics(self, chain: str, address: str, t: Dict[str, Any]) -> TokenMetrics:
        """å°† GMGN æ•°æ®è½¬æ¢ä¸º TokenMetrics"""
        # å¤„ç†æ—¶é—´æˆ³
        ts = t.get("open_timestamp") or t.get("pool_creation_timestamp")
        created = None
        if ts:
            try:
                created = datetime.fromtimestamp(ts, tz=timezone.utc).replace(tzinfo=None)
            except: 
                pass

        # å¤„ç†å‰10æŒä»“å æ¯”ï¼ˆå·²ç»æ˜¯å°æ•°å½¢å¼ï¼Œå¦‚ 0.0082 = 0.82%ï¼‰
        top10_ratio = _to_float(t.get("top_10_holder_rate"))
        
        # å¤„ç†æœ€å¤§æŒä»“å æ¯”
        max_holder_ratio = _to_float(t.get("max_holder_ratio"))
        
        # å¤„ç†æµåŠ¨æ€§ï¼ˆæ³¨æ„ï¼šå¯èƒ½æ˜¯ SOL è€Œä¸æ˜¯ USDï¼‰
        liquidity = _to_float(t.get("liquidity"))
        # TODO: å¦‚æœéœ€è¦è½¬æ¢ä¸º USDï¼Œéœ€è¦è·å– SOL ä»·æ ¼å¹¶ä¹˜ä»¥ liquidity
        
        return TokenMetrics(
            chain=chain, 
            address=address, 
            symbol=t.get("symbol", ""), 
            name=t.get("name"),
            price_usd=_to_float(t.get("price")),
            price_change_5m=_to_float(t.get("price_change_percent5m")),
            market_cap=_to_float(t.get("market_cap")),
            liquidity_usd=liquidity,  # æ³¨æ„ï¼šå¯èƒ½éœ€è¦è½¬æ¢ä¸º USD
            pool_created_at=created,
            trades_5m=_to_int(t.get("swaps_5m")) or _to_int(t.get("swaps")) or 0,
            holders=_to_int(t.get("holder_count")),
            top10_ratio=top10_ratio,  # å·²ç»æ˜¯å°æ•°å½¢å¼ï¼ˆ0.0082 = 0.82%ï¼‰
            max_holder_ratio=max_holder_ratio,  # ä» top holders æ¥å£è·å–
            extra={"source": "gmgn"},
        )

    async def _gmgn_ratios(self, chain: str, address: str) -> Tuple[Optional[float], Optional[float]]:
        # ç®€åŒ–ç‰ˆå•ç‹¬è·å– - å¦‚æœä¸»æ¥å£å¤±è´¥ï¼Œè¿™é‡Œä¹Ÿå¤±è´¥
        return None, None

    async def _fetch_risk_scores(self, metrics: TokenMetrics) -> None:
        """è·å– SolSniffer å’Œ TokenSniffer é£é™©è¯„åˆ†"""
        # å¹¶è¡Œè·å–ä¸¤ä¸ªè¯„åˆ†
        sol_task = self._fetch_sol_sniffer_score(metrics.chain, metrics.address)
        token_task = self._fetch_token_sniffer_score(metrics.chain, metrics.address)

        sol_score, token_score = await asyncio.gather(sol_task, token_task)

        metrics.sol_sniffer_score = sol_score
        metrics.token_sniffer_score = token_score

    async def _fetch_sol_sniffer_score(self, chain: str, address: str) -> Optional[float]:
        """è·å– SolSniffer é£é™©è¯„åˆ† (0-100)"""
        try:
            if chain.lower() not in ("sol", "solana"):
                return None

            # è·å– API key
            api_key = SOL_SNIFFER_API_KEY
            if not api_key:
                logger.debug("SolSniffer API key not configured")
                return None

            # SolSniffer API v2.0 ç«¯ç‚¹ï¼šGET /token/{address}
            url = f"https://solsniffer.com/api/v2/token/{address}"

            # ä½¿ç”¨ httpx å®¢æˆ·ç«¯è¯·æ±‚ï¼ŒAPI key ä½œä¸º Header
            headers = {"X-API-KEY": api_key}
            resp = await self.client.get(url, headers=headers, timeout=10)

            if resp.status_code == 200:
                data = resp.json()
                # æ ¹æ®APIæ–‡æ¡£ï¼Œè¿”å›æ ¼å¼ä¸º tokenData.score
                token_data = data.get("tokenData", {})
                score = token_data.get("score")
                if score is not None and isinstance(score, (int, float)):
                    logger.info(f"âœ… SolSniffer score fetched: {score}")
                    return float(score)
                else:
                    logger.debug(f"SolSniffer API returned invalid score: {score}")
            else:
                logger.debug(f"SolSniffer API returned status {resp.status_code}")

        except Exception as e:
            logger.debug(f"Error fetching SolSniffer score: {e}")

        return None

    async def _fetch_token_sniffer_score(self, chain: str, address: str) -> Optional[float]:
        """è·å– TokenSniffer é£é™©è¯„åˆ† (0-100)"""
        try:
            # æ ¹æ®é“¾ç±»å‹ç¡®å®š TokenSniffer çš„ chain_id
            token_sniffer_chain_map = {
                "solana": 1399811149,  # Solana chain ID in TokenSniffer
                "bsc": 56,            # BSC chain ID
                "ethereum": 1,        # Ethereum chain ID
                "polygon": 137,       # Polygon chain ID
                "matic": 137,
                # æ·»åŠ å…¶ä»–æ”¯æŒçš„é“¾
            }

            sniffer_chain_id = token_sniffer_chain_map.get(chain.lower())
            if sniffer_chain_id is None:
                logger.debug(f"TokenSniffer does not support chain: {chain}")
                return None

            # è·å– API key
            api_key = TOKEN_SNIFFER_API_KEY
            if not api_key:
                logger.debug("TokenSniffer API key not configured")
                return None

            url = f"https://tokensniffer.com/api/v2/tokens/{sniffer_chain_id}/{address}"

            # ä½¿ç”¨ httpx å®¢æˆ·ç«¯è¯·æ±‚
            params = {
                "apikey": api_key,
                "include_metrics": "true",
            }
            resp = await self.client.get(url, params=params, timeout=10)

            if resp.status_code == 200:
                data = resp.json()
                metrics = data.get("metrics") or data.get("data", {}).get("metrics", {})
                score = None
                if isinstance(metrics, dict):
                    score = metrics.get("score")
                if score is None:
                    tests = data.get("tests", {})
                    if isinstance(tests, dict):
                        score = tests.get("score")
                if score is not None and isinstance(score, (int, float)):
                    return float(score)
                else:
                    logger.debug(f"TokenSniffer API returned invalid score: {score}")
            else:
                logger.debug(f"TokenSniffer API returned status {resp.status_code}")

        except Exception as e:
            logger.debug(f"Error fetching TokenSniffer score: {e}")

        return None 



def _select_pair(pairs: List[Dict[str, Any]], chain: str) -> Dict[str, Any]:
    chain_lower = "solana" if chain.lower() == "sol" else chain.lower()
    filtered = [p for p in pairs if str(p.get("chainId", "")).lower() == chain_lower]
    target = filtered or pairs
    target.sort(key=lambda p: _to_float(p.get("liquidity", {}).get("usd") if isinstance(p.get("liquidity"), dict) else 0) or 0, reverse=True)
    return target[0]

def _to_float(v): 
    """è½¬æ¢ä¸ºfloatï¼ŒNoneè¿”å›Noneï¼Œ0è¿”å›0.0"""
    if v is None:
        return None
    try:
        return float(v)
    except (ValueError, TypeError):
        return None
def _to_int(v): return int(v) if v is not None else None
def _to_datetime(v): 
    if not v: return None
    try: return datetime.fromtimestamp(int(v)/1000, tz=timezone.utc).replace(tzinfo=None)
    except: return None

--- File: ./src/main.py ---
from __future__ import annotations

import asyncio
import html
import logging
import os
from datetime import datetime, timezone
from decimal import Decimal, ROUND_DOWN
from pathlib import Path
from typing import List, Optional, Tuple

from telethon import events

from .bot import BotApp, chain_hint, CA_PATTERN
from .chart import render_chart
from .client_pool import ClientPool
from .data_fetcher import DataFetcher
from .filters import apply_filters
from .models import TokenMetrics
from .state import StateStore
from .storage import DedupeStore
from .task_scheduler import TaskScheduler
from .utils import short_num, format_time_ago


def build_caption(m: TokenMetrics, filtered: Optional[List[str]] = None) -> str:
    # è¾…åŠ©å‡½æ•°
    def fmt_num(n): 
        return short_num(n) if n is not None else "N/A"
    
    def fmt_pct(n, precision=2): 
        """
        æ ¼å¼åŒ–ç™¾åˆ†æ¯”
        precision: å°æ•°ä½æ•°ï¼Œé»˜è®¤2ä½ã€‚å¯¹äºæœ€å¤§æŒä»“å æ¯”ï¼Œä½¿ç”¨1ä½ï¼ˆç²¾ç¡®åˆ°0.1ï¼‰
        """
        if n is None:
            return "N/A"
        # ä½¿ç”¨å‘ä¸‹å–æ•´çš„æ–¹å¼ä¿ç•™æŒ‡å®šå°æ•°ä½æ•°ï¼Œé¿å…å››èˆäº”å…¥
        try:
            val = Decimal(str(n)) * Decimal("100")
            # æ ¹æ®precisionå‚æ•°å†³å®šå°æ•°ä½æ•°
            if precision == 1:
                val = val.quantize(Decimal("0.1"), rounding=ROUND_DOWN)
            else:
                val = val.quantize(Decimal("0.01"), rounding=ROUND_DOWN)
            return f"{val}%"
        except Exception:
            return "N/A"
    
    def fmt_int(n): 
        return str(int(n)) if n is not None else "N/A"
    
    # 1. å¸‚å€¼ & æ± å­
    mc = fmt_num(m.market_cap)
    liq = fmt_num(m.liquidity_usd)
    
    # 2. æ—¶é—´ï¼ˆä¼˜å…ˆä½¿ç”¨ç¬¬ä¸€ä¸ªKçº¿æ—¶é—´ï¼Œå³çœŸæ­£çš„å¼€ç›˜æ—¶é—´ï¼‰
    open_time = m.first_trade_at or m.pool_created_at
    age = format_time_ago(open_time) if open_time else "N/A"
    
    # 3. äº¤æ˜“æ¬¡æ•°
    tx_5m = fmt_int(m.trades_5m)
    
    # 4. æ„å»º GMGN é“¾æ¥
    # æ ¹æ®é“¾ç±»å‹è‡ªåŠ¨ç”Ÿæˆ
    chain_path = "sol" if m.chain.lower() == "solana" else m.chain.lower()
    gmgn_url = f"https://gmgn.ai/{chain_path}/token/{m.address}"
    
    # å¸ƒå±€æ„å»º
    # æ ‡é¢˜è¡Œï¼šåç§° + é“¾æ¥
    title_line = f"ğŸ’Š <b>{m.symbol}</b> ({m.name or 'Unknown'})"
    
    # æ•°æ®çŸ©é˜µ (æ¨ªæ’å¯†é›†æ˜¾ç¤º)
    # ç¬¬ä¸€è¡Œï¼šå¸‚å€¼ | æ± å­ | å¼€ç›˜
    line1 = f"ğŸ’°å¸‚å€¼: ${mc} | ğŸ’§æ± å­: ${liq} | â°å¼€ç›˜: {age}"
    
    # ç¬¬äºŒè¡Œï¼šCA (å•è¡Œæ–¹ä¾¿å¤åˆ¶)
    line2 = f"<code>{m.address}</code>"
    
    # ç¬¬ä¸‰è¡Œï¼šæŒæœ‰ | å‰10 | 5åˆ†äº¤æ˜“ | æœ€å¤§æŒä»“
    line3 = f"ğŸ‘¥æŒæœ‰: {fmt_int(m.holders)} | ğŸ”ŸTop10: {fmt_pct(m.top10_ratio)} | ğŸ“‰5mäº¤æ˜“: {tx_5m} | ğŸ³æœ€å¤§: {fmt_pct(m.max_holder_ratio, precision=1)}"

    # ç¬¬å››è¡Œï¼šé£é™©è¯„åˆ† (SolSniffer | TokenSniffer)
    sol_score = f"{m.sol_sniffer_score:.1f}" if m.sol_sniffer_score is not None else "N/A"
    token_score = f"{m.token_sniffer_score:.1f}" if m.token_sniffer_score is not None else "N/A"
    line4 = f"ğŸ›¡ï¸é£é™©è¯„åˆ†: SolSniffer {sol_score} | TokenSniffer {token_score}"

    # ç¬¬äº”è¡Œï¼šé“¾æ¥
    line5 = f"ğŸ”— <a href='{gmgn_url}'>ç‚¹å‡»å‰å¾€ GMGN æŸ¥çœ‹è¯¦æƒ… â†—ï¸</a>"
    
    content = [title_line, line1, line2, line3, line4, line5]
    
    if filtered:
        content.append(f"\nğŸš« <b>å·²è¿‡æ»¤åŸå› :</b> {', '.join(filtered)}")
        
    return "\n".join(content)


async def main():
    # Configure detailed logging
    log_level = os.getenv("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, log_level),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Keep httpx and telegram logs at WARNING to reduce noise
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("telegram").setLevel(logging.WARNING)
    logging.getLogger("telegram.ext").setLevel(logging.WARNING)
    
    # Create logger for our application
    logger = logging.getLogger("ca_filter_bot")
    logger.setLevel(logging.DEBUG if log_level == "DEBUG" else logging.INFO)
    
    logger.info("=" * 60)
    logger.info("ğŸš€ CA Filter Bot Starting...")
    logger.info("=" * 60)
    
    # Load environment variables
    from dotenv import load_dotenv
    load_dotenv()
    
    # Required env vars
    tg_bot_token = os.getenv("TG_BOT_TOKEN")
    if not tg_bot_token:
        raise RuntimeError("TG_BOT_TOKEN is required")
    
    # Optional env vars
    gmgn_headers = {}
    if os.getenv("GMGN_COOKIE"):
        gmgn_headers["cookie"] = os.getenv("GMGN_COOKIE")
        logger.info("âœ… GMGN Cookie configured")
    if os.getenv("GMGN_UA"):
        gmgn_headers["user-agent"] = os.getenv("GMGN_UA")
        logger.info("âœ… GMGN User-Agent configured")
    if not gmgn_headers:
        logger.warning("âš ï¸  GMGN headers not configured, may have limited access")
    
    
    # Admin IDs
    admin_ids_str = os.getenv("ADMIN_IDS", "")
    admin_ids = [int(x.strip()) for x in admin_ids_str.split(",") if x.strip()] if admin_ids_str else []
    if admin_ids:
        logger.info(f"âœ… Admin IDs configured: {len(admin_ids)} admin(s)")
    else:
        logger.warning("âš ï¸  No admin IDs configured, admin features will be disabled")
    
    # Tasks config path (for MTProto clients + tasks)
    tasks_config_path = os.getenv("TASK_CONFIG_PATH", "config/tasks.json")
    
    state = StateStore("state.json", admin_ids)
    logger.info("ğŸ’¾ State store initialized")

    fetcher = DataFetcher(
        gmgn_headers=gmgn_headers,
    )
    logger.info("ğŸ“¡ DataFetcher initialized")
    
    dedupe = DedupeStore()
    logger.info("ğŸ”„ Dedupe store initialized (in-memory)")

    bot_app = BotApp(admin_ids, state, process_ca=None, scheduler=None)
    client_pool = ClientPool(tasks_config_path)
    try:
        await client_pool.load()
    except Exception as e:
        logger.warning(f"âš ï¸ Failed to load clients: {e}")

    async def process_ca(chain: str, ca: str, force_push: bool = False, task_id: Optional[str] = None) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Process CA and return (photo_path, caption, error_message).
        If successful, returns (photo_path, caption, None).
        If failed, returns (None, None, error_message).
        task_id: ç”¨äºæŒ‰ä»»åŠ¡ç‹¬ç«‹çš„è¿‡æ»¤ä¸æ¨é€é…ç½®ï¼›è‹¥ä¸º None åˆ™ä½¿ç”¨å½“å‰ä»»åŠ¡æˆ–é»˜è®¤ç©ºé…ç½®ã€‚
        """
        # é€‰æ‹©ä»»åŠ¡é…ç½®
        task_id_in_use = task_id or await state.current_task()
        tasks_snap = await state.all_tasks()
        task_cfg = tasks_snap.get(task_id_in_use) if tasks_snap else None

        key = f"{task_id_in_use or 'global'}:{chain}:{ca}"
        logger.info(f"ğŸ” Processing CA: {chain} - {ca[:8]}... (task={task_id_in_use})")
        
        if not force_push:
            logger.debug(f"ğŸ” Checking dedupe for: {key[:64]}...")
            # è®¾ç½®å»é‡æ—¶é—´ä¸º1å¤©ï¼ˆ86400ç§’ï¼‰ï¼Œé˜²æ­¢é‡å¤æ¨é€
            is_seen = await dedupe.seen(key, ttl=86400)
            logger.debug(f"ğŸ” Dedupe check result: {is_seen}")
            if is_seen:
                logger.info(f"â­ï¸  CA already processed for task={task_id_in_use}, skipping: {ca[:8]}...")
                return None, None, None  # Already processed, skip silently
        
        try:
            logger.info(f"ğŸ“¥ Fetching data for {chain} - {ca[:8]}...")
            start_time = asyncio.get_event_loop().time()
            
            # GMGN åŸºç¡€æ•°æ® + GeckoTerminal Kçº¿
            metrics_task = asyncio.create_task(fetcher.fetch_all(chain, ca))
            
            # GeckoTerminalï¼š1å°æ—¶ 1m K çº¿
            try:
                bars = await fetcher.fetch_chart_by_address(chain, ca, minutes=60)
            except Exception as e:
                error_detail = f"å›¾è¡¨æ•°æ®è·å–å¤±è´¥ï¼ˆGeckoTerminal API å¤±è´¥ï¼‰: {str(e)}"
                logger.error(error_detail)
                logger.debug(f"GeckoTerminal error details:", exc_info=True)
                return None, None, error_detail

            # ç­‰å¾… GMGN æ•°æ®
            metrics = await metrics_task
            
            # æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸
            if isinstance(metrics, Exception):
                raise metrics
            if not bars:
                error_detail = "å›¾è¡¨æ•°æ®ä¸ºç©ºï¼ˆæœªè¿”å› 60 åˆ†é’Ÿ 1m K çº¿ï¼‰ï¼Œå·²åœæ­¢æ¨é€"
                logger.error(error_detail)
                return None, None, error_detail
            logger.info(f"âœ… Data fetched: {metrics.symbol} | Price: ${metrics.price_usd} | MCap: ${metrics.market_cap}")
            logger.info(f"ğŸ“ˆ Chart data: {len(bars)} bars from GeckoTerminal")
            
            # ä½¿ç”¨ K çº¿çš„ç¬¬ä¸€æ ¹æ—¶é—´ä½œä¸ºå¼€ç›˜æ—¶é—´
            if bars and len(bars) > 0:
                try:
                    first_bar = bars[0]
                    first_bar_time = first_bar.get("t") or first_bar.get("time")
                    if first_bar_time:
                        # åˆ¤æ–­æ˜¯ç§’è¿˜æ˜¯æ¯«ç§’æ—¶é—´æˆ³
                        if first_bar_time > 1e11:
                            first_bar_time = first_bar_time / 1000
                        first_trade_dt = datetime.fromtimestamp(first_bar_time, tz=timezone.utc).replace(tzinfo=None)
                        metrics.first_trade_at = first_trade_dt
                        logger.info(f"â° First trade time from K-line: {first_trade_dt}")
                except Exception as e:
                    logger.warning(f"âš ï¸ Failed to extract first trade time from K-line: {e}")
            
            # è¿‡æ»¤æ£€æŸ¥
            filters_cfg = await state.filters_cfg(task_id=task_id_in_use)
            passed, reasons = apply_filters(metrics, filters_cfg)
            logger.info(f"ğŸ” Filter check: {'âœ… PASSED' if passed else 'âŒ FAILED'}")
            if reasons:
                logger.info(f"   Reasons: {', '.join(reasons)}")
            
            elapsed = asyncio.get_event_loop().time() - start_time
            logger.info(f"â±ï¸  Total processing time: {elapsed:.2f}s")
            
        except ValueError as e:
            # Specific error messages
            error_msg = str(e)
            if "No pairs found" in error_msg:
                error_detail = (
                    f"**æ•°æ®è·å–å¤±è´¥**\n\n"
                    f"å·²å°è¯•ä»ä»¥ä¸‹æ•°æ®æºè·å–ï¼š\n"
                    f"â€¢ GMGN APIï¼ˆä¼˜å…ˆï¼Œæ”¯æŒæ–°ä»£å¸ï¼‰\n"
                    f"â€¢ DexScreener APIï¼ˆå¤‡é€‰ï¼‰\n\n"
                    f"**å¯èƒ½åŸå› ï¼š**\n"
                    f"â€¢ ä»£å¸éå¸¸æ–°ï¼Œæ•°æ®æºå°šæœªåŒæ­¥\n"
                    f"â€¢ åˆçº¦åœ°å€é”™è¯¯\n"
                    f"â€¢ ä»£å¸å°šæœªåˆ›å»ºäº¤æ˜“å¯¹\n\n"
                    f"ğŸ’¡ æç¤ºï¼šå¦‚æœä»£å¸æ¥è‡ªGMGNä¸”åˆšåˆ›å»ºï¼Œè¯·ç¨ç­‰å‡ åˆ†é’Ÿåå†è¯•"
                )
                logging.warning("æ•°æ®æºæœªæ‰¾åˆ°ä»£å¸ %s %s", chain, ca)
            else:
                error_detail = f"æ•°æ®è·å–å¤±è´¥: {error_msg}"
                logging.warning("æ•°æ®è·å–å¤±è´¥ %s %s: %s", chain, ca, error_msg)
            return None, None, error_detail
        except Exception as e:
            error_detail = f"æ•°æ®è·å–å¤±è´¥: {str(e)}"
            logging.warning("fetch failed %s %s: %s", chain, ca, e)
            return None, None, error_detail
        
        caption = build_caption(metrics, None if passed else reasons)

        # ç”Ÿæˆå›¾è¡¨ï¼ˆä¸å†ä½¿ç”¨ fallbackï¼Œè‹¥å¤±è´¥ç›´æ¥æŠ¥é”™ï¼‰
        logger.info(f"ğŸ“¸ Generating chart for {ca[:8]}...")
        photo_buffer = None
        try:
            if bars and len(bars) > 0:
                photo_buffer = render_chart(metrics, bars)
                if photo_buffer:
                    logger.info(f"âœ… Chart generated from Birdeye data")
                else:
                    raise ValueError("å›¾è¡¨æ¸²æŸ“å¤±è´¥ï¼Œæœªç”Ÿæˆå›¾ç‰‡ç¼“å†²")
            else:
                raise ValueError("å›¾è¡¨æ•°æ®ä¸ºç©ºï¼Œæ— æ³•ç”Ÿæˆå›¾è¡¨")
        except Exception as e:
            error_msg = f"å›¾è¡¨ç”Ÿæˆå¤±è´¥: {str(e)}"
            logger.error(f"âŒ {error_msg}")
            return None, None, error_msg
        
        # If force_push (manual query), always return result to user
        if force_push:
            if not passed:
                # è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦ï¼Œé¿å…è§£æé”™è¯¯
                escaped_reasons = [html.escape(r) for r in reasons]
                error_msg = f"ä»£å¸æœªé€šè¿‡ç­›é€‰æ¡ä»¶ï¼š\n" + "\n".join(f"â€¢ {r}" for r in escaped_reasons)
                return photo_buffer, caption, error_msg
            # Return photo and caption for manual query (even if no push targets)
            return photo_buffer, caption, None
        
        # Auto mode: only push if passed filters
        if passed:
            targets = []
            if task_cfg:
                targets = task_cfg.get("push_chats", [])
            logger.info(f"ğŸ“¤ Pushing to {len(targets)} target(s): {targets}")
            if targets:
                for chat_id in targets:
                    try:
                        # åˆ¤æ–­æ˜¯æœºå™¨äººï¼ˆ@usernameï¼‰è¿˜æ˜¯ç¾¤ç»„/é¢‘é“ï¼ˆæ•°å­—IDï¼‰
                        is_bot = isinstance(chat_id, str) and chat_id.startswith("@")
                        
                        if is_bot:
                            # æœºå™¨äººï¼šä½¿ç”¨æ‰€æœ‰ MTProto å®¢æˆ·ç«¯ï¼Œåªå‘é€çº¯ CA æ–‡æœ¬ï¼Œä¸å¸¦ä»»ä½•æ–‡ä»¶
                            payload = ca  # å¯¹æœºå™¨äººä»…å‘é€ CA åœ°å€
                            sent_count = 0
                            for cli_name, cli in client_pool.clients.items():
                                if cli.is_connected():
                                    try:
                                        # ç›´æ¥ä½¿ç”¨ç”¨æˆ·åå‘é€ï¼Œä¸å…ˆè·å–å®ä½“ï¼Œé¿å… Telethon ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜
                                        # Telethon çš„ send_message ä¼šè‡ªåŠ¨è§£æç”¨æˆ·å
                                        await cli.send_message(
                                            chat_id, 
                                            payload
                                        )
                                        sent_count += 1
                                        logger.info(f"âœ… Sent to bot {chat_id} via MTProto client {cli_name}")
                                    except Exception as e:
                                        error_msg = str(e)
                                        # å¦‚æœæ˜¯ TLObject è§£æé”™è¯¯ï¼Œå¯èƒ½æ˜¯ Telethon ç‰ˆæœ¬é—®é¢˜
                                        if "Constructor ID" in error_msg or "TLObject" in error_msg:
                                            logger.warning(f"âš ï¸  Telethon version compatibility issue for client {cli_name} when sending to {chat_id}")
                                            logger.debug(f"   Error: {error_msg[:200]}")
                                            logger.info(f"   Try updating Telethon: pip install --upgrade telethon")
                                        else:
                                            logger.warning(f"âš ï¸  Failed to send to bot {chat_id} via MTProto client {cli_name}: {error_msg[:200]}")
                                        logger.debug(f"   Full error:", exc_info=True)
                            if sent_count == 0:
                                logger.warning(f"âš ï¸  No connected MTProto client available or all failed, cannot send to bot {chat_id}")
                            elif sent_count < len([c for c in client_pool.clients.values() if c.is_connected()]):
                                logger.info(f"ğŸ“Š Sent via {sent_count}/{len([c for c in client_pool.clients.values() if c.is_connected()])} connected client(s)")
                        else:
                            # ç¾¤ç»„/é¢‘é“ï¼šä½¿ç”¨ Bot API
                            if photo_buffer:
                                photo_buffer.seek(0)
                                await bot_app.app.bot.send_photo(
                                    chat_id=chat_id, 
                                    photo=photo_buffer, 
                                    caption=caption,
                                    parse_mode="HTML"
                                )
                            else:
                                await bot_app.app.bot.send_message(
                                    chat_id=chat_id, 
                                    text=caption,
                                    parse_mode="HTML"
                                )
                            logger.info(f"âœ… Sent to chat {chat_id} via Bot API")
                    except Exception as e:
                        logger.error(f"âŒ Failed to send to chat {chat_id}: {e}")
            else:
                logger.warning(f"âš ï¸  No push targets configured, skipping auto push")
        else:
            logger.info(f"â­ï¸  Token filtered out, not pushing")
        
        return photo_buffer, caption, None

    # inject process_ca now that it is defined
    bot_app.process_ca = process_ca
    
    # ä½¿ç”¨æ‰€æœ‰ MTProto å®¢æˆ·ç«¯ä½œä¸ºç¾¤æ¶ˆæ¯ç›‘å¬è€…ï¼ˆå¯ç›‘å¬åˆ°å…¶ä»–æœºå™¨äººçš„å‘è¨€ï¼‰
    if client_pool.clients:
        def register_listener(mt_listener, client_name: str):
            @mt_listener.on(events.NewMessage)
            async def _mt_on_message(event, _client_name=client_name):
                try:
                    chat = await event.get_chat()
                    chat_id = getattr(chat, "id", None)
                    if chat_id is None:
                        return
                    text = event.raw_text or ""
                    if not text:
                        return

                    logger.info(f"ğŸ“¨ [MTProto:{_client_name}] Incoming message in chat {chat_id}: {text[:80]!r}")

                    # æ ¹æ®ä»»åŠ¡é…ç½®ä¸­çš„ listen_chats è¿‡æ»¤éœ€è¦å¤„ç†çš„ä»»åŠ¡
                    snap = await state.snapshot()
                    tasks = snap.get("tasks", {})
                    if not tasks:
                        return

                    username = getattr(chat, "username", None)
                    name_keys = []
                    if username:
                        name_keys.append(f"@{username}")

                    matched_tasks: List[str] = []
                    for tid, cfg in tasks.items():
                        if not cfg.get("enabled"):
                            continue
                        listens = cfg.get("listen_chats", [])
                        # ç»Ÿä¸€æˆå­—ç¬¦ä¸² / æ•°å­—é›†åˆï¼Œå¹¶å…¼å®¹ Bot API çš„ -100 å‰ç¼€å½¢å¼
                        listen_keys_str = set()
                        listen_ids_int = set()
                        for v in listens:
                            listen_keys_str.add(str(v))
                            if isinstance(v, int):
                                listen_ids_int.add(v)
                                # å¦‚æœæ˜¯ Bot API çš„ -100 å‰ç¼€ç¾¤ç»„ IDï¼Œæå–å‡º channel_id å½¢å¼
                                s = str(v)
                                if s.startswith("-100") and len(s) > 4 and s[4:].isdigit():
                                    ch_id = int(s[4:])
                                    listen_ids_int.add(ch_id)
                                    listen_keys_str.add(str(ch_id))

                        chat_id_str = str(chat_id)
                        # ç›´æ¥æ•°å­—åŒ¹é… / å­—ç¬¦ä¸²åŒ¹é… / @username åŒ¹é…
                        if (
                            chat_id in listen_ids_int
                            or chat_id_str in listen_keys_str
                            or any(k in listen_keys_str for k in name_keys)
                        ):
                            matched_tasks.append(tid)

                    if not matched_tasks:
                        return

                    logger.info(f"ğŸ“¨ [MTProto:{_client_name}] Message received from chat {chat_id} for tasks: {matched_tasks}")
                    found = set(CA_PATTERN.findall(text))
                    if not found:
                        return
                    logger.info(f"ğŸ” [MTProto:{_client_name}] Found {len(found)} CA(s) in message: {[ca[:8] + '...' for ca in found]}")

                    for ca in found:
                        for tid in matched_tasks:
                            asyncio.create_task(bot_app._process_ca_bg(chain_hint(ca), ca, task_id=tid))
                except Exception as e:
                    logger.error(f"âŒ MTProto listener error ({_client_name}): {e}", exc_info=True)

        for cname, cli in client_pool.clients.items():
            register_listener(cli, cname)
        logger.info(f"ğŸ“¥ MTProto å®¢æˆ·ç«¯ç›‘å¬å·²å¯ç”¨ï¼ˆ{len(client_pool.clients)} ä¸ªå®¢æˆ·ç«¯ï¼Œæ”¯æŒç›‘å¬ç¾¤å†…å…¶ä»–æœºå™¨äººæ¶ˆæ¯ï¼‰")
    else:
        logger.info("â„¹ï¸ æœªé…ç½® MTProto å®¢æˆ·ç«¯ï¼Œç¾¤æ¶ˆæ¯ç›‘å¬ä»…ä¾èµ– Bot APIï¼ˆæ— æ³•çœ‹åˆ°å…¶ä»–æœºå™¨äººæ¶ˆæ¯ï¼‰")
    
    # å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨ï¼ˆå³ä¾¿å½“å‰æ²¡æœ‰ä»»åŠ¡ï¼Œä¹Ÿä¿æŒå®ä¾‹å¯ç”¨ï¼Œé¿å… /add_client ç­‰å‘½ä»¤æç¤ºæœªå¯ç”¨ï¼‰
    scheduler = TaskScheduler(client_pool, process_ca, state_store=state)
    scheduler.load_tasks(client_pool.tasks_config())
    await scheduler.start()
    bot_app.scheduler = scheduler
    logger.info(f"ğŸ—“ï¸  Task scheduler started with {len(scheduler.tasks)} task(s)")
    
    snap = await state.snapshot()
    logger.info("=" * 60)
    logger.info("ğŸ“Š Current Configuration:")
    logger.info(f"   Listen chats: {len(snap.get('listen_chats', []))} groups")
    logger.info(f"   Push chats: {len(snap.get('push_chats', []))} groups")
    logger.info(f"   Filters: {sum(1 for f in snap.get('filters', {}).values() if f.get('min') is not None or f.get('max') is not None)} configured")
    logger.info("=" * 60)
    logger.info("âœ… Bot ready! Waiting for messages...")
    logger.info("=" * 60)
    
    await bot_app.run()


if __name__ == "__main__":
    asyncio.run(main())


--- File: ./src/filters.py ---
from __future__ import annotations

from datetime import datetime
from typing import List, Tuple

from .models import FilterConfig, TokenMetrics
from .utils import check_range


def apply_filters(metrics: TokenMetrics, cfg: FilterConfig) -> Tuple[bool, List[str]]:
    reasons: List[str] = []

    checks = [
        ("market_cap_usd", metrics.market_cap, cfg.market_cap_usd),
        ("liquidity_usd", metrics.liquidity_usd, cfg.liquidity_usd),
        ("top10_ratio", metrics.top10_ratio, cfg.top10_ratio),
        ("holder_count", metrics.holders, cfg.holder_count),
        ("max_holder_ratio", metrics.max_holder_ratio, cfg.max_holder_ratio),
        ("trades_5m", metrics.trades_5m, cfg.trades_5m),
        ("sol_sniffer_score", metrics.sol_sniffer_score, cfg.sol_sniffer_score),
        ("token_sniffer_score", metrics.token_sniffer_score, cfg.token_sniffer_score),
    ]

    for name, value, fr in checks:
        ok, msg = check_range(_convert_to_float(value), fr)
        if not ok:
            reasons.append(f"{name} {msg}")

    # pool open minutes
    # ä¼˜å…ˆä½¿ç”¨ç¬¬ä¸€ä¸ªKçº¿çš„æ—¶é—´ï¼ˆçœŸæ­£çš„å¼€ç›˜æ—¶é—´ï¼‰ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ pool_created_at
    if cfg.open_minutes.is_set():
        open_time = metrics.first_trade_at or metrics.pool_created_at
        if open_time is None:
            reasons.append("open_minutes missing")
        else:
            minutes = (datetime.utcnow() - open_time).total_seconds() / 60
            ok, msg = check_range(minutes, cfg.open_minutes)
            if not ok:
                reasons.append(f"open_minutes {msg}")

    return len(reasons) == 0, reasons


def _convert_to_float(value):
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


--- File: ./src/state.py ---
from __future__ import annotations

import asyncio
import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from .models import FilterConfig, FilterRange


def _filters_to_dict(f: FilterConfig) -> Dict[str, Dict[str, Optional[float]]]:
    return {
        "market_cap_usd": f.market_cap_usd.dict(),
        "liquidity_usd": f.liquidity_usd.dict(),
        "open_minutes": f.open_minutes.dict(),
        "top10_ratio": f.top10_ratio.dict(),
        "holder_count": f.holder_count.dict(),
        "max_holder_ratio": f.max_holder_ratio.dict(),
        "trades_5m": f.trades_5m.dict(),
        "sol_sniffer_score": f.sol_sniffer_score.dict(),
        "token_sniffer_score": f.token_sniffer_score.dict(),
    }


def _filters_from_dict(data: Dict[str, Dict[str, Optional[float]]]) -> FilterConfig:
    def fr(name: str) -> FilterRange:
        return FilterRange(**(data.get(name) or {}))

    return FilterConfig(
        market_cap_usd=fr("market_cap_usd"),
        liquidity_usd=fr("liquidity_usd"),
        open_minutes=fr("open_minutes"),
        top10_ratio=fr("top10_ratio"),
        holder_count=fr("holder_count"),
        max_holder_ratio=fr("max_holder_ratio"),
        trades_5m=fr("trades_5m"),
        sol_sniffer_score=fr("sol_sniffer_score"),
        token_sniffer_score=fr("token_sniffer_score"),
    )


class StateStore:
    def __init__(self, path: str | Path, admin_ids: List[int]):
        self.path = Path(path)
        self.lock = asyncio.Lock()
        # å¤šä»»åŠ¡é…ç½®ï¼š
        # - current_task: å½“å‰é€‰ä¸­çš„ä»»åŠ¡ID
        # - tasks: {task_id: {"enabled": bool, "listen_chats": [], "push_chats": [], "filters": {...}}}
        self._state = {
            "current_task": None,
            "tasks": {},
        }
        self._load_existing()

    def _load_existing(self):
        if self.path.exists():
            try:
                data = json.loads(self.path.read_text())
                default_filters = _filters_to_dict(FilterConfig())
                # è¿ç§»æ—§ç‰ˆç»“æ„ï¼ˆæ—  tasksï¼‰
                if "tasks" not in data:
                    legacy_listen = data.get("listen_chats", [])
                    legacy_push = data.get("push_chats", [])
                    legacy_filters = data.get("filters", default_filters)
                    if not isinstance(legacy_filters, dict):
                        legacy_filters = {}
                    for key, value in default_filters.items():
                        legacy_filters.setdefault(key, dict(value))
                    self._state["tasks"] = {
                        "default": {
                            "enabled": True,
                            "listen_chats": legacy_listen,
                            "push_chats": legacy_push,
                            "filters": legacy_filters,
                        }
                    }
                    self._state["current_task"] = "default" if legacy_listen or legacy_push else None
                else:
                    # ç¡®ä¿ enabled å­—æ®µå­˜åœ¨
                    tasks = data.get("tasks", {})
                    for tid, cfg in tasks.items():
                        cfg.setdefault("enabled", False)
                        cfg.setdefault("listen_chats", [])
                        cfg.setdefault("push_chats", [])
                        filters_cfg = cfg.get("filters") or {}
                        if not isinstance(filters_cfg, dict):
                            filters_cfg = {}
                        for key, value in default_filters.items():
                            filters_cfg.setdefault(key, dict(value))
                        cfg["filters"] = filters_cfg
                    self._state.update(data)
                    # å¦‚æœæ²¡æœ‰ current_taskï¼Œåˆ™é€‰ç¬¬ä¸€ä¸ª
                    if not self._state.get("current_task") and tasks:
                        self._state["current_task"] = list(tasks.keys())[0]
            except Exception:
                # ignore corrupt state; keep defaults
                pass

    async def _write(self):
        self.path.write_text(json.dumps(self._state, indent=2))

    async def save(self):
        async with self.lock:
            await self._write()

    async def snapshot(self) -> Dict[str, Any]:
        async with self.lock:
            return json.loads(json.dumps(self._state))

    # --- ä»»åŠ¡çº§åˆ«å­˜å– ---
    def _ensure_task(self, task_id: str):
        if task_id not in self._state["tasks"]:
            self._state["tasks"][task_id] = {
                "enabled": False,
                "listen_chats": [],
                "push_chats": [],
                "filters": _filters_to_dict(FilterConfig()),
                    "start_time": None,
                    "end_time": None,
            }

    async def create_task(self, task_id: str) -> bool:
        async with self.lock:
            if task_id in self._state["tasks"]:
                return False
            self._ensure_task(task_id)
            # æ–°ä»»åŠ¡é»˜è®¤æš‚åœ
            self._state["tasks"][task_id]["enabled"] = False
            if not self._state.get("current_task"):
                self._state["current_task"] = task_id
            await self._write()
            return True

    async def delete_task(self, task_id: str) -> bool:
        async with self.lock:
            if task_id in self._state["tasks"]:
                self._state["tasks"].pop(task_id, None)
                if self._state.get("current_task") == task_id:
                    self._state["current_task"] = None
                await self._write()
                return True
            return False

    async def set_task_enabled(self, task_id: str, enabled: bool) -> bool:
        async with self.lock:
            if task_id not in self._state["tasks"]:
                return False
            self._state["tasks"][task_id]["enabled"] = enabled
            await self._write()
            return True

    async def set_current_task(self, task_id: Optional[str]):
        async with self.lock:
            self._state["current_task"] = task_id
            if task_id:
                self._ensure_task(task_id)
            await self._write()

    async def current_task(self) -> Optional[str]:
        async with self.lock:
            return self._state.get("current_task")

    async def task_settings(self, task_id: str) -> Dict[str, Any]:
        async with self.lock:
            self._ensure_task(task_id)
            return json.loads(json.dumps(self._state["tasks"][task_id]))

    async def all_tasks(self) -> Dict[str, Any]:
        async with self.lock:
            return json.loads(json.dumps(self._state["tasks"]))

    # --- ç›‘å¬ç¾¤ç»„ ---
    async def add_listen(self, chat_id: Union[int, str], task_id: Optional[str] = None):
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id:
                return
            self._ensure_task(task_id)
            task = self._state["tasks"][task_id]
            if chat_id not in task["listen_chats"]:
                task["listen_chats"].append(chat_id)
            await self._write()

    async def del_listen(self, chat_id: Union[int, str], task_id: Optional[str] = None):
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id:
                return
            self._ensure_task(task_id)
            task = self._state["tasks"][task_id]
            if chat_id in task["listen_chats"]:
                task["listen_chats"].remove(chat_id)
            await self._write()

    # --- æ¨é€ç›®æ ‡ ---
    async def add_push(self, chat_id: Union[int, str], task_id: Optional[str] = None):
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id:
                return
            self._ensure_task(task_id)
            task = self._state["tasks"][task_id]
            if chat_id not in task["push_chats"]:
                task["push_chats"].append(chat_id)
            await self._write()

    async def del_push(self, chat_id: Union[int, str], task_id: Optional[str] = None):
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id:
                return
            self._ensure_task(task_id)
            task = self._state["tasks"][task_id]
            if chat_id in task["push_chats"]:
                task["push_chats"].remove(chat_id)
            await self._write()

    # --- ç­›é€‰æ¡ä»¶ ---
    async def set_filter(self, name: str, min_val: Optional[float], max_val: Optional[float], task_id: Optional[str] = None):
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id:
                return
            self._ensure_task(task_id)
            filters = self._state["tasks"][task_id]["filters"]
            if name not in filters:
                raise ValueError("unknown filter")
            filters[name] = {"min": min_val, "max": max_val}
            await self._write()

    async def filters_cfg(self, task_id: Optional[str] = None) -> FilterConfig:
        async with self.lock:
            task_id = task_id or self._state.get("current_task")
            if not task_id or task_id not in self._state["tasks"]:
                return _filters_from_dict(_filters_to_dict(FilterConfig()))
            return _filters_from_dict(self._state["tasks"][task_id]["filters"])

    # --- ä»»åŠ¡æ—¶é—´çª— ---
    async def set_task_window(self, task_id: str, start_time: Optional[str], end_time: Optional[str]) -> bool:
        """
        start_time/end_time: å­—ç¬¦ä¸² "HH:MM" æˆ– None
        """
        async with self.lock:
            if task_id not in self._state["tasks"]:
                return False
            self._state["tasks"][task_id]["start_time"] = start_time
            self._state["tasks"][task_id]["end_time"] = end_time
            await self._write()
            return True

